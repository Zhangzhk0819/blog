<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mac 中多版本 Python 开发环境搭建</title>
    <url>/2017/10/19/build-python-development-environment-in-mac/</url>
    <content><![CDATA[<p>由于 Mac 上很多系统软件依赖于其自带的 python 环境，如果直接使用系统自带的 python 环境进行开发，很可能会把该环境搞乱，威胁系统安全，因此在开发的时候我们最好能在独立的环境中进行开发。另外，在 python 开发过程中，经常需要在不同版本之间切换，特别是 2.7 和 3.5，因此需要搭建一个方便 python 版本切换的开发环境。</p>
<a id="more"></a>

<p>下面详细介绍 mac 中多版本 python 开发环境的搭建方法。</p>
<h2 id="安装-homebrew"><a href="#安装-homebrew" class="headerlink" title="安装 homebrew"></a>安装 homebrew</h2><p>在各个版本的 Linux 系统中，可以使用包管理工具来快速安装各种软件，比如 Ubuntu 的 apt-get，Debian/Kali 的 dpkg，Fedora 的 yum 等。同样，在 Mac 系统中，也有一个比较好用的包管理系统，那就是 homebrew。Mac 系统默认是没有 homebrew 的，需要通过以下命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>

<p>安装完成后就可以通过 brew intall pakage-name 命令来安装各种软件了。在这篇博客中主要用来安装下面的 pyenv 和 pyenv-virtualenv。</p>
<h2 id="安装-pyenv"><a href="#安装-pyenv" class="headerlink" title="安装 pyenv"></a>安装 pyenv</h2><p>Mac 系统一般自带有 python 2.7，为了方便 python 版本切换，我们可以通过 pyenv 这个软件来进行快速管理。pyenv 可以管理 python2, python3 以及 annaconda, miniconda 在内的各种 python 发行版本，所有版本文件都存放在 ~/.pyenv/versions 文件夹里面。</p>
<p>首先利用下面命令安装 pyenv:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install pyenv</span><br></pre></td></tr></table></figure>

<p>然后通过以下两条命令把环境变量写入 ~/.bash_profile 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'export PYENV_ROOT="$HOME/.pyenv"'</span> &gt;&gt; ~/.bash_profile</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'export PATH="$PYENV_ROOT/bin:$PATH"'</span> &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>接下来通过把 pyenv init 写入 shell 来开启 shims 和自动补齐功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">'if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\n  eval "$(pyenv init -)"\nfi'</span> &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>这个时候就可以通过 pyenv 来管理 python 版本了，下面简单介绍 pyenv 的几条常用命令。</p>
<p>查看本机安装的 python 版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pyenv versions</span><br></pre></td></tr></table></figure>
<p>星号表示当前正在使用的 Python 版本。使用 python -V 确认版本。</p>
<p>查看可安装的 python 版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv install -l</span><br></pre></td></tr></table></figure>

<p>Python 安装与卸载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pyenv install 2.7.3   <span class="comment"># 安装python</span></span><br><span class="line">$ pyenv uninstall 2.7.3 <span class="comment"># 卸载python</span></span><br></pre></td></tr></table></figure>

<p>Python 版本切换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pyenv global 2.7.3  <span class="comment"># 设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。</span></span><br><span class="line">$ pyenv <span class="built_in">local</span> 2.7.3 <span class="comment"># 设置 Python 本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。</span></span><br><span class="line">$ pyenv shell 2.7.3 <span class="comment"># 设置面向 shell 的 Python 版本，通过设置当前 shell 的 PYENV_VERSION 环境变量的方式。</span></span><br><span class="line">$ pyenv shell --<span class="built_in">unset</span> <span class="comment"># 取消当前 shell 设定的版本。</span></span><br><span class="line">$ pyenv <span class="built_in">rehash</span>  <span class="comment"># 创建垫片路径（为所有已安装的可执行文件创建 shims，如：~/.pyenv/versions/*/bin/*，因此，每当你增删了 Python 版本或带有可执行文件的包（如 pip）以后，都应该执行一次本命令）</span></span><br></pre></td></tr></table></figure>
<p>python 的使用优先级为 shell &gt; local &gt; global。</p>
<h2 id="安装-pyenv-virtualenv"><a href="#安装-pyenv-virtualenv" class="headerlink" title="安装 pyenv-virtualenv"></a>安装 pyenv-virtualenv</h2><p>pyenv-virtual 是用来管理虚拟环境的。这里我们需要认真区分版本管理和环境管理的区别，版本管理用于管理 python 的不同发行版本，而环境管理用于为不同项目定制开发环境。在 pyenv 中，环境是从版本中派生出来的，可以继承所属版本的第三方包，也可以为特定项目定制第三方包，而又不至于影响原始的 python 版本。对于 pyenv 来说，虚拟环境和版本一样，也存放在 ~/.pyenv/versions 文件夹中，其管理跟版本管理类似，可以使用 uninstall, global, local 等命令。</p>
<p>我们同样使用 homebrew 来安装 pyenv-virtualenv：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install pyenv-virtualenv</span><br></pre></td></tr></table></figure>

<p>之后，我们就可以通过以下命令来创建虚拟环境了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv virtualenv &lt;python-version&gt; &lt;virtualenv-name&gt;</span><br></pre></td></tr></table></figure>
<p>其中，python-version 是虚拟环境的版本类型，virtualenv-name 为该虚拟环境的名字，可以自己任取。</p>
<p>接下来就可以通过下面命令激活和关闭虚拟环境了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv activate virtualenv-name</span><br><span class="line">pyenv deactivate</span><br></pre></td></tr></table></figure>
<p>激活后 shell 的最前端会出现，(virtualenv-name)，代表已经进入虚拟环境。</p>
<p>如果我们想每次进入某个项目便自动激活特定虚拟环境，可以通过 local 命令来设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv <span class="built_in">local</span> virtualenv-name</span><br></pre></td></tr></table></figure>




<h2 id="安装-pip"><a href="#安装-pip" class="headerlink" title="安装 pip"></a>安装 pip</h2><p>pip 是 python 的包安装工具，安装 pip 后，所有的 python 包都可以通过 pip isntall pkg 进行安装。首先通过下面命令获取 pip 安装脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://bootstrap.pypa.io/get-pip.py</span><br></pre></td></tr></table></figure>
<p>wget 是一个好用的文件下载工具，下载的文件放在当前文件夹中。如果还没有安装 wget，也可以通过 homebrew 进行安装。</p>
<p>接下来就可以用 python 执行该安装脚本了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo python get-pip.py</span><br></pre></td></tr></table></figure>
<p>需要注意的是，由于我们使用了 pyenv 来管理 python 版本，每次使用 pip 都是把相应的包安装到当前系统使用的 python 版本中。如果我们在虚拟环境中，那么相应的包便安装到相应的虚拟环境中了。</p>
<h2 id="Python-开发常用软件"><a href="#Python-开发常用软件" class="headerlink" title="Python 开发常用软件"></a>Python 开发常用软件</h2><p>在 python 开发过程中，使用一些软件能大大加快开发进程，这些软件都可以通过 pip 进行安装。</p>
<ul>
<li>ipython</li>
</ul>
<h2 id="有用链接"><a href="#有用链接" class="headerlink" title="有用链接"></a>有用链接</h2><ul>
<li><a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="noopener">homebrew 官网</a></li>
<li><a href="http://www.jb51.net/article/76931.htm" target="_blank" rel="noopener">在Mac OS上搭建Python的开发环境</a></li>
<li><a href="http://einverne.github.io/post/2017/04/pyenv.html" target="_blank" rel="noopener">使用 pyenv 管理 Python 版本</a></li>
<li><a href="https://github.com/pyenv/pyenv#homebrew-on-mac-os-x" target="_blank" rel="noopener">Pyenv github</a></li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 使用方法与常用命令</title>
    <url>/2017/09/21/commands-of-git/</url>
    <content><![CDATA[<p>本文总结一些 Git 常用命令。</p>
<a id="more"></a>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><img src="/images/git_command.jpg" width=100% height=100% align=center/>

<h2 id="Commit-类别"><a href="#Commit-类别" class="headerlink" title="Commit 类别"></a>Commit 类别</h2><ul>
<li>init：项目初始化（用于项目初始化或其他某种行为的开始描述，不影响代码）</li>
<li>feat：新功能（feature）</li>
<li>fix：修补bug</li>
<li>docs：文档（documentation）</li>
<li>opt：优化和改善，比如弹窗进行确认提示等相关的，不会改动逻辑和具体功能等</li>
<li>style： 格式（不影响代码运行的变动）</li>
<li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li>
<li>test：增加测试</li>
<li>other：用于难以分类的类别（不建议使用，但一些如删除不必要的文件，更新.ignore之类的可以使用）</li>
</ul>
<!-- more -->

<h2 id="有用链接"><a href="#有用链接" class="headerlink" title="有用链接"></a>有用链接</h2><ul>
<li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰教程</a></li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Ceph 实现多服务器存储共享</title>
    <url>/2019/07/13/deploy-ceph-for-storage-sharing/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Ceph 是一个分布式文件存储系统，具体工作原理可以参考<a href="http://docs.ceph.org.cn/" target="_blank" rel="noopener">官方文档</a>。本博客主要介绍如何使用 ceph 实现多服务器之间的存储共享。这样一来，在使用 pycharm 进行 python 开发时，只需要与其中一台服务器进行文件同步。由于服务器之间的存储是共享的，所有需要用来跑代码的服务器都同步更新了所有最新修改，这能极大提高 python 多进程运行的效率。</p>
<a id="more"></a>

<h2 id="部署-ceph-集群"><a href="#部署-ceph-集群" class="headerlink" title="部署 ceph 集群"></a>部署 ceph 集群</h2><p>为了实现多服务器中间的存储共享，首先需要搭建一个 ceph 集群。本教程主要针对 CentOS 系统，其他系统请自行 google。这部分内容主要参考[2]，我进行了实际部署并对其内容进行了整理。</p>
<h3 id="机器准备"><a href="#机器准备" class="headerlink" title="机器准备"></a>机器准备</h3><p>本教程介绍的 ceph 集群包含一个管理节点，一个 monitor 节点和三个 osd 节点。其中 monitor 节点和 osd 节点可以放在同一台服务器上，因此我们需要四台服务器，hostname 分别为：</p>
<ul>
<li>管理节点：admin-node</li>
<li>monitor 节点：node1</li>
<li>osd 节点：node1, node2, node3</li>
</ul>
<ol>
<li><p>修改四台机器的 hostname，以管理节点为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;etc&#x2F;hostname &#x2F;etc&#x2F;hostname.bak</span><br><span class="line">vim &#x2F;etc&#x2F;hostname</span><br></pre></td></tr></table></figure>
<p>其中第一条命令的作用是对之前的 hostname 文件进行备份，在操作 linux 系统文件时我们需要养成备份的好习惯。</p>
</li>
<li><p>修改四台机器的 hosts 文件，以管理节点为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;etc&#x2F;hosts &#x2F;etc&#x2F;hosts.bak</span><br><span class="line">vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure>
<p>修改成以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.0.100 admin-node</span><br><span class="line">192.168.0.101 node1</span><br><span class="line">192.168.0.102 node2</span><br><span class="line">192.168.0.103 node3</span><br></pre></td></tr></table></figure>
<p>四台服务器的 IP 地址根据实际情况填写。</p>
</li>
</ol>
<p>在接下来的步骤中，由于不同节点的配置方式不同，因此用括号标注了相应步骤是在哪个节点上操作的。</p>
<ul>
<li>管理节点：admin-node</li>
<li>ceph 节点：node1, node2, node3</li>
<li>所有节点：admin-node, node1, node2, node3</li>
</ul>
<h3 id="ceph-节点安装"><a href="#ceph-节点安装" class="headerlink" title="ceph 节点安装"></a>ceph 节点安装</h3><ol>
<li><p>安装 NTP 服务（所有节点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install ntp ntpdate ntp-doc</span><br></pre></td></tr></table></figure>
<p>需要注意的是，当使用 yum 安装软件时，如果 terminal 提示某些源不能用或者安装比较慢时，可以相应的源备份掉并添加新的源，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv ambarim.repo ambarim.repo.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建部署 ceph 的新用户（所有节点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在目录 ceph-user-folder 创建用户 ceph-user-name</span><br><span class="line">sudo useradd -d &#x2F;ceph-user-folder -m ceph-user-name</span><br><span class="line"># 修改 ceph-user-name 用户的密码</span><br><span class="line">sudo passwd ceph-user-name</span><br><span class="line"># 为 ceph-user-name 用户添加 sudo 权限</span><br><span class="line">echo &quot;ceph-user-name ALL &#x3D; (root) NOPASSWD:ALL&quot; | sudo tee &#x2F;etc&#x2F;sudoers.d&#x2F;ceph-user-name</span><br><span class="line">sudo chmod 0440 &#x2F;etc&#x2F;sudoers.d&#x2F;cehph-user-name</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置管理节点免密登录 ceph 节点（管理节点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 切换用户至刚创建的 ceph-user-name 用户</span><br><span class="line">su - ceph-user-name</span><br><span class="line"># 生成密钥对</span><br><span class="line">ssh-gen</span><br><span class="line"># 将公钥拷贝到 ceph 节点</span><br><span class="line">ssh-copy-id ceph-user-name@node1</span><br><span class="line">ssh-copy-id ceph-user-name@node2</span><br><span class="line">ssh-copy-id ceph-user-name@node3</span><br><span class="line"># 修改 ~&#x2F;.ssh&#x2F;config 文件</span><br><span class="line">sudo vim ~&#x2F;.ssh&#x2F;config</span><br></pre></td></tr></table></figure>
<p>加入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host admin-node</span><br><span class="line">   Hostname admin-node</span><br><span class="line">   User ceph-user-name</span><br><span class="line">Host node1</span><br><span class="line">   Hostname node1</span><br><span class="line">   User ceph-user-name</span><br><span class="line">Host node2</span><br><span class="line">   Hostname node2</span><br><span class="line">   User ceph-user-name</span><br><span class="line">Host node3</span><br><span class="line">   Hostname node3</span><br><span class="line">   User ceph-user-name</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭防火墙（ceph 节点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop firewalld</span><br><span class="line">sudo systemctl disable firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 TTY 终端（ceph 节点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 编辑 &#x2F;etc&#x2F;sudoers 文件</span><br><span class="line">sudo visudo</span><br><span class="line"># 注释掉 Defaults requiretty 选项</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭 selinux（ceph 节点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo setenforce 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 epel 源（管理节点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils &amp;&amp; sudo yum-config-manager --add-repo https:&#x2F;&#x2F;dl.fedoraproject.org&#x2F;pub&#x2F;epel&#x2F;7&#x2F;x86_64&#x2F; &amp;&amp; sudo yum install --nogpgcheck -y epel-release &amp;&amp; sudo rpm --import &#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-EPEL-7 &amp;&amp; sudo rm &#x2F;etc&#x2F;yum.repos.d&#x2F;dl.fedoraproject.org*</span><br></pre></td></tr></table></figure>
</li>
<li><p>把源加入软件库（管理节点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;yum.repos.d&#x2F;ceph.repo</span><br></pre></td></tr></table></figure>
<p>添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Ceph]</span><br><span class="line">name&#x3D;Ceph packages for $basearch</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ceph&#x2F;rpm-jewel&#x2F;el7&#x2F;x86_64&#x2F;</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">type&#x3D;rpm-md</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ceph&#x2F;keys&#x2F;release.asc</span><br><span class="line">priority&#x3D;1</span><br><span class="line"></span><br><span class="line">[Ceph-noarch]</span><br><span class="line">name&#x3D;Ceph noarch packages</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ceph&#x2F;rpm-jewel&#x2F;el7&#x2F;noarch&#x2F;</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">type&#x3D;rpm-md</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ceph&#x2F;keys&#x2F;release.asc</span><br><span class="line">priority&#x3D;1</span><br><span class="line"></span><br><span class="line">[ceph-source]</span><br><span class="line">name&#x3D;Ceph source packages</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ceph&#x2F;rpm-jewel&#x2F;el7&#x2F;SRPMS&#x2F;</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">type&#x3D;rpm-md</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ceph&#x2F;keys&#x2F;release.asc</span><br><span class="line">priority&#x3D;1</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 ceph-deploy（管理节点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum install ceph-deploy</span><br><span class="line">sudo yum install yum-plugin-priorities</span><br></pre></td></tr></table></figure>
<p>yum update 耗时较长，请耐心等待。</p>
</li>
</ol>
<h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><p>集群搭建主要在管理节点上进行，用到上一步安装的 ceph-deploy 命令。</p>
<ol>
<li><p>创建安装文件夹，用于存储安装配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir my-cluster</span><br><span class="line">cd my-cluster</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建集群并初始化 monitor 节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置 node1 为 monitor 节点</span><br><span class="line">ceph-deploy new node1</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &#39;$a\osd pool default size &#x3D; 2&#39; ceph.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>在所有节点上安装 ceph<br>教程[2]提供的方法是直接在管理节点上执行以下命令一键在所有节点上安装 ceph。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy install admin-node node1 node2 node3</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>然而在我实际的安装过程中，只有管理节点能成功安装，其他节点都失败了。我的解决方案是直接登录其他节点先把 ceph 安装好，然后在管理节点上执行 ceph-deploy install 命令。具体来说，首先在 ceph 节点上添加 epel 源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;yum.repo.d&#x2F;epel.repo</span><br></pre></td></tr></table></figure>
<p>添加以下内容并保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[epel]</span><br><span class="line">name&#x3D;Extra Packages for Enterprise Linux 7 - $basearch</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;epel&#x2F;7&#x2F;$basearch</span><br><span class="line">failovermethod&#x3D;priority</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-EPEL-7</span><br><span class="line"></span><br><span class="line">[epel-debuginfo]</span><br><span class="line">name&#x3D;Extra Packages for Enterprise Linux 7 - $basearch - Debug</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;epel&#x2F;7&#x2F;$basearch&#x2F;debug</span><br><span class="line">failovermethod&#x3D;priority</span><br><span class="line">enabled&#x3D;0</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-EPEL-7</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line"></span><br><span class="line">[epel-source]</span><br><span class="line">name&#x3D;Extra Packages for Enterprise Linux 7 - $basearch - Source</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;epel&#x2F;7&#x2F;SRPMS</span><br><span class="line">failovermethod&#x3D;priority</span><br><span class="line">enabled&#x3D;0</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-EPEL-7</span><br><span class="line">gpgcheck&#x3D;0</span><br></pre></td></tr></table></figure>
<p>然后使用 yum 进行安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum -y install ceph</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>初始化 monitor 节点，并收集所有秘钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy mon create-initial</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加三个 OSD<br>首先登陆到 ceph 节点，给每个 OSD 守护进程创建一个目录，并添加权限，以 node1 为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh node1</span><br><span class="line">sudo mkdir &#x2F;var&#x2F;local&#x2F;osd0</span><br><span class="line">sudo chmod 777 &#x2F;var&#x2F;local&#x2F;osd0&#x2F;</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>其中，需要为不同 ceph 节点指定不同的 osd 编号。</p>
</li>
</ol>
<p>然后从管理节点执行 ceph-deploy 来准备 OSD</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy osd prepare node1:&#x2F;var&#x2F;local&#x2F;osd0 node2:&#x2F;var&#x2F;local&#x2F;osd1 node3:&#x2F;var&#x2F;local&#x2F;osd2</span><br></pre></td></tr></table></figure>

<p>最后激活 OSD</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy osd activate node1:&#x2F;var&#x2F;local&#x2F;osd0 node2:&#x2F;var&#x2F;local&#x2F;osd1 node3:&#x2F;var&#x2F;local&#x2F;osd2</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>把配置文件和 admin 秘钥拷贝到管理节点和 ceph 节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy admin admin-node node1 node2 node3</span><br></pre></td></tr></table></figure>
</li>
<li><p>在所有节点上添加对 ceph.client.admin.keyring 的操作权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod +r &#x2F;etc&#x2F;ceph&#x2F;ceph.client.admin.keyring</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查集群健康状况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph -s</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>如果想要添加新的 OSD 节点，可以在 ceph 安装好后，重复第6-9步。</p>
<h2 id="安装-cephfs-文件系统"><a href="#安装-cephfs-文件系统" class="headerlink" title="安装 cephfs 文件系统"></a>安装 cephfs 文件系统</h2><p>服务器之间的存储共享主要通故宫 cephfs 文件系统实现，有了 ceph 集群，安装和配置 cephfs 文件系统相对来说简单一些。本部分主要参考教程[3]。</p>
<ol>
<li><p>创建 MDS 服务器（管理节点）<br>如果要运行并挂载 cephfs 文件系统，必须至少创建一个元数据服务器（ceph MDS），可以在管理节点上使用 ceph-deploy 命令将 ceph MDS 安装到 OSD 节点上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy mds create node1</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 data pool 和 metadata pool（安装了 MDS 的 ceph 节点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd pool create cephfs_data 128</span><br><span class="line">ceph osd pool create cephfs_metadata 128</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 cephfs 文件系统（安装了 MDS 的 ceph 节点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph fs new cephfs cephfs_metadata cephfs_data</span><br></pre></td></tr></table></figure>
<p>其中 cephfs 为文件系统名称，可以自己指定。</p>
</li>
<li><p>检查 MDS 服务器列表和状态（安装了 MDS 的 ceph 节点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph fs ls</span><br><span class="line">ceph mds stat</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="挂载-cephfs-文件系统"><a href="#挂载-cephfs-文件系统" class="headerlink" title="挂载 cephfs 文件系统"></a>挂载 cephfs 文件系统</h2><p>安装好 cephfs 文件系统后，便可以在客户机上挂载 cephfs 文件系统了。一个 cephfs 文件系统可以挂载在很多客户机上，因此这些客户机可以共享 cephfs 指定的存储空间。需要注意的是，ceph 集群中的节点本身也可以作为客户机。</p>
<p>创建 cephfs 目录并远程挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;mnt&#x2F;cephfs</span><br><span class="line">sudo mount -t ceph &lt;monitor-ip&gt;:6789:&#x2F; &#x2F;mnt&#x2F;cephfs -o name&#x3D;admin,secret&#x3D;&lt;admin-key&gt;</span><br></pre></td></tr></table></figure>
<p>其中<monitor-ip>为 ceph 集群 monitor 节点的 ip 地址，<admin-key>可以在 ceph 集群中任意一个节点中通过以下命令得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph auth get client.admin</span><br></pre></td></tr></table></figure>



<h2 id="创建家目录在-cephfs-文件系统上的新用户"><a href="#创建家目录在-cephfs-文件系统上的新用户" class="headerlink" title="创建家目录在 cephfs 文件系统上的新用户"></a>创建家目录在 cephfs 文件系统上的新用户</h2><p>为了方便使用，我们可以在每台客户机上创建一个家目录位于 cephfs 文件系统上的新用户。<br>最简单的方法是在每台客户机上分别创建用户 user-name，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo useradd -d &#x2F;mnt&#x2F;cephfs&#x2F;user-name -m user-name</span><br><span class="line">sudo passwd user-name</span><br><span class="line">echo &quot;user-name ALL &#x3D; (root) NOPASSWD:ALL&quot; | sudo tee &#x2F;etc&#x2F;sudoers.d&#x2F;user-name</span><br><span class="line">sudo chmod 0440 &#x2F;etc&#x2F;sudoers.d&#x2F;user-name</span><br></pre></td></tr></table></figure>

<p>需要注意的是，不同客户机创建的新用户一般有不同的 id，如果某台客户机创建新用户的 id 与 cephfs 文件的 owner id 不一致时，我们是无法使用该新建用户登录的。此时需要修改新用户 id 与 cephfs owner id 一致。</p>
<p>首先用 root 登录服务器，查看挂载 cephfs 的 owner id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;mnt&#x2F;cephfs&#x2F;</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>

<p>然后查看新建用户 id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id user-name</span><br></pre></td></tr></table></figure>

<p>如果新用户 id 与 cephfs owner id 不一致，修改新用户 id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod -u &lt;cephfs-owner-id&gt; user-name</span><br><span class="line">groupmod -g &lt;cephfs-owner-id&gt; user-name</span><br></pre></td></tr></table></figure>

<p>如果需要管理的用户很多时，可以使用<a href="http://www.voidcn.com/article/p-uqufzazi-bqn.html" target="_blank" rel="noopener">LDAP</a>来集中式管理账户，这样就不需要每次在所有客户机上都创建一个用户了。接下来有时间会部署一个LDAP并出相应的教程，敬请期待。</p>
<h2 id="有用链接"><a href="#有用链接" class="headerlink" title="有用链接"></a>有用链接</h2><p>[1] <a href="http://docs.ceph.org.cn/" target="_blank" rel="noopener">Ceph 官方文档</a><br>[2] <a href="https://www.cnblogs.com/zengzhihua/p/9884341.html" target="_blank" rel="noopener">Ceph/共享存储汇总</a><br>[3] <a href="https://www.howtoing.com/how-to-mount-cephfs-on-centos-7" target="_blank" rel="noopener">如何在CentOS 7上安装CephFS</a><br>[4] <a href="https://www.jianshu.com/p/c22ff79c4452" target="_blank" rel="noopener">CephFS 使用</a><br>[5] <a href="http://www.voidcn.com/article/p-uqufzazi-bqn.html" target="_blank" rel="noopener">搭建一套OpenLDAP系统，实现账号的统一管理</a></p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>ceph</tag>
        <tag>distributed storage</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 服务器连接浙大 VPN</title>
    <url>/2019/07/16/install-zjunet/</url>
    <content><![CDATA[<p>这篇博客主要介绍 Linux 服务器如何连接浙大 VPN。</p>
<a id="more"></a>

<h2 id="安装-zjunet"><a href="#安装-zjunet" class="headerlink" title="安装 zjunet"></a>安装 zjunet</h2><p>由于在 vpn 设置好之前是无法连接外网的，所以只能手动下载 zjunet rpm 包到本地，然后通过 scp 上传到 Linux 服务器。另外，zjunet 依赖于 xl2tpd 程序，也需要通过 rpm 包安装。具体命令如下：<br>本地下载 <a href="https://github.com/QSCTech/zjunet/releases" target="_blank" rel="noopener">zjunet</a> 和 <a href="https://centos.pkgs.org/7/epel-x86_64/xl2tpd-1.3.8-3.el7.x86_64.rpm.html" target="_blank" rel="noopener">xl2tpd</a> rpm 包，并执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp .&#x2F;zjunet.rpm root@server_ip:~&#x2F;zjunet.rpm</span><br><span class="line">scp .&#x2F;xl2tpd.rpm root@server_ip:~&#x2F;xl2tpd.rpm</span><br></pre></td></tr></table></figure>
<p>两个包的名字根据具体下载文件名确定，下面命令类似。</p>
<p>通过 ssh 登录到远程服务器并执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install xl2tpd.rpm</span><br><span class="line">yum -y install zjunet.rpm</span><br></pre></td></tr></table></figure>

<p>如果安装 zjunet 时提示缺少 dnsutils 这个包，可以首先执行以下命令忽略依赖然后安装，主要是因为这个包是 Ubuntu 里面的，在 CentOS 里面没有这个包，相同功能对应另外一个包。忽略以后似乎对连接 vpn 没啥影响。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -i zjunet.rpm --nodeps</span><br></pre></td></tr></table></figure>

<h2 id="连接浙大-vpn"><a href="#连接浙大-vpn" class="headerlink" title="连接浙大 vpn"></a>连接浙大 vpn</h2><p>安装好 zjunet 后可以直接在终端输入<code>zjunet</code>来查看可用命令，当然也可以通过该命令判断程序是否正确安装。常用的命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加 vpn 用户</span><br><span class="line">zjunet user add</span><br><span class="line"># 连接 vpn</span><br><span class="line">zjunet vpn -c</span><br><span class="line"># 断开 vpn</span><br><span class="line">zjunet vpn -d</span><br></pre></td></tr></table></figure>


<h2 id="有用链接"><a href="#有用链接" class="headerlink" title="有用链接"></a>有用链接</h2><p>[1] <a href="https://centos.pkgs.org/7/epel-x86_64/xl2tpd-1.3.8-3.el7.x86_64.rpm.html" target="_blank" rel="noopener">xl2tpd rpm 包下载</a><br>[2] <a href="https://github.com/QSCTech/zjunet/releases" target="_blank" rel="noopener">zjunet rpm 包下载</a></p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用远程计算资源</title>
    <url>/2017/10/30/how-to-use-purdue-cluster/</url>
    <content><![CDATA[<p>在普渡学习期间，为了提高训练模型的速度，获得了使用多个远程计算资源的权限，包括课题组自己搭建的 swarm 和 crater 服务器，普渡计算中心集群 Conte [1]，以及匹兹堡超算中心（Pittsburgh Supercomputing Center）Bridges 计算集群。下面记录一下使用各个远程计算资源的方法。</p>
<a id="more"></a>

<h2 id="swarm-和-crater"><a href="#swarm-和-crater" class="headerlink" title="swarm 和 crater"></a>swarm 和 crater</h2><h3 id="远程登录主机"><a href="#远程登录主机" class="headerlink" title="远程登录主机"></a>远程登录主机</h3><p>在 macos 或 Linux 中，可以直接使用 ssh 命令登录远程主机，使用方法为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh username_in_remote_host@remote_host</span><br></pre></td></tr></table></figure>

<p>其中，username_in_remote_host 是自己在远程主机上拥有的用户名，remote_host 是远程主机的 IP 地址或者域名。登录远程主机以后就跟在自己电脑上一样操作了。另外，可以使用下面的 scp 命令在本地主机和远程主机之间传输文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp path_to_local_file username_in_remote_host@remote_host:path_to_remote_file</span><br></pre></td></tr></table></figure>

<p>值得一提的是，我们可以在本地使用多个 shell 登录远程主机，而且在远程主机上可以使用同样的命令登录另外一台远程主机，比如说课题组还有一台服务器 crater 只能通过内网访问，而我的 mac 只能连无线网，无法接入内网，只能通过 ssh 先连接到可以外网访问的服务器 swarm，然后在 swarm 上再通过 ssh 连接 crater。</p>
<h3 id="ssh-免密登录"><a href="#ssh-免密登录" class="headerlink" title="ssh 免密登录"></a>ssh 免密登录</h3><p>正常情况下，每次在本地使用 ssh 和 scp 的时候，都需要输入一次远程主机的登录密码，非常麻烦。为方便起见，我们可以使用 ssh 秘钥对来进行免密登录。</p>
<p>首先，在本地主机使用<code>ssh-keygen</code>命令产生秘钥对，密钥对默认存放在 ~/.ssh 文件夹中，需要注意的是，在产生秘钥过程中会提示设置密码，我们直接按回车键，表示不设置密码，否则就失去了免密登录的意义了。接下来使用 scp 命令把 ~/.ssh 文件夹中的 id_rsa.pub 文件远程拷贝到远程主机的 ~/.ssh 文件夹（如果没有，可以使用<code>mkdir .ssh</code>命令创建）中，接下来使用下面命令对远程主机中的 id_rsa.pub 进行重命名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mv id_rsa.pub authorized_keys</span><br></pre></td></tr></table></figure>

<p>这个时候当我们再在本地执行 ssh 命令时，不需要输密码就能进入远程主机了。</p>
<h2 id="Conte"><a href="#Conte" class="headerlink" title="Conte"></a>Conte</h2><p>front end，计算集群</p>
<h3 id="存储空间使用"><a href="#存储空间使用" class="headerlink" title="存储空间使用"></a>存储空间使用</h3><h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><h2 id="Bridges"><a href="#Bridges" class="headerlink" title="Bridges"></a>Bridges</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://www.rcac.purdue.edu/knowledge/conte" target="_blank" rel="noopener">Conte user guide</a></li>
<li><a href="https://www.psc.edu/bridges/user-guide" target="_blank" rel="noopener">Bridges user guide</a></li>
</ol>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>cluster</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>在一台设备上管理两个 Github 账号</title>
    <url>/2017/09/17/manage-two-github-accounts-in-one-computer/</url>
    <content><![CDATA[<h2 id="有用链接"><a href="#有用链接" class="headerlink" title="有用链接"></a>有用链接</h2><p><a href="http://www.jianshu.com/p/f2bef9737a8a" target="_blank" rel="noopener">简书</a></p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用 Hexo 在 Github 上搭建个人博客</title>
    <url>/2017/09/13/how-to-create-blog-by-hexo/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hexo 是一种基于 node.js 的静态博客框架。</p>
<a id="more"></a>

<h2 id="安装-node-js-和-hexo"><a href="#安装-node-js-和-hexo" class="headerlink" title="安装 node.js 和 hexo"></a>安装 node.js 和 hexo</h2><p>首先到<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网</a>下载安装 node.js, windows 版本是一个 msi 文件，直接下载双击安装就行。安装程序会自动添加环境变量，此时需要重启才能生效。</p>
<p>接下来的操作大多数基于命令行，windows 系统下可以使用 git bash（git 安装与使用方法这里暂不详述）, 其操作与 linux 类似，个人感觉比 cmd 好用。</p>
<p>接下来通过下面命令安装 hexo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>其中 npm 是 node.js 的包管理工具，类似于 ruby 的 gem, python 的 pip, Ubuntu 的 apt-get。接下来，到到你想存放博客文件的目录，执行下面命令新建一个博客：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure>

<p>上面命令中的 blog 可以任意取名，用于存放博客文件，然后 cd 进去 blog 文件。接下来执行下面命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>npm install 是 npm 的安装命令，会自动在blog目录下寻找 package.json 作为配置文件安装必要的模块。此时就可以在本地通过以下命令启动hexo服务器了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>启动本地服务器后，便可以通过 <a href="http://localhost:4000/" target="_blank" rel="noopener">localhost:4000</a> 来访问自己本地的 hexo 博客了。需要注意的是，这个时候打开的这个 git bash 已经被占用了，不能关闭，否则 hexo 服务器也就关闭了。如果要执行其他命令，需要打开一个新的 git bash。</p>
<h2 id="把-hexo-部署到-github-上"><a href="#把-hexo-部署到-github-上" class="headerlink" title="把 hexo 部署到 github 上"></a>把 hexo 部署到 github 上</h2><p>接下来就可以把本地的 hexo 博客部署到 github 上了。</p>
<p>首先，我们需要在 github 上新建一个 repo, repo 的名字为 yourname.github.io，其中 yourname 为你自己的 github 的名字。</p>
<p>在正式部署之前，需要做好以下三项准备：</p>
<ul>
<li>安装 git 部署工具</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<ul>
<li>blog 文件夹里面的 _config.yml 文件的 deploy 部分需要做以下配置：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<ul>
<li>设置本地 git bash 与你 github 账号之间的秘钥。使用一下命令生成 ssh key:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail@email.com"</span></span><br></pre></td></tr></table></figure>

<p>其中 <a href="mailto:youremail@email.com">youremail@email.com</a> 是 github bash 的邮箱，cd 到存放秘钥的目录，利用以下命令打印出公钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>复制打印出来的公钥，粘贴到 GitHub 账号的 setting -&gt; SSH keys。</p>
<p>这个时候就可以通过以下命令一键部署本地 hexo 到 github 上面了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure>

<p>至此，hexo 就已经部署好了，接下来说一说更好得使用 hexo。</p>
<h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>前面利用 hexo init 建立博客时使用的是默认模板，个人感觉不是很好看，hexo 有着丰富的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题模板</a>，而且切换起来非常方便，只需要在 blog 文件夹下面执行下面命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/MOxFIVE/hexo-theme-yelee themes/yelee</span><br></pre></td></tr></table></figure>

<p>上面的链接为主题模板的 github 地址，下载的主题放在 /blog/themes 文件夹下面。事实上，打开 themes 文件夹我们发现里面已经有一个默认模板 landscape 在里面了。</p>
<p>最后把 blog 文件夹里面的 _config.yml 文件的 theme 字段修改成对应的主题名字就好了。</p>
<h2 id="博客插图"><a href="#博客插图" class="headerlink" title="博客插图"></a>博客插图</h2><p>由于所有的博客都是使用 markdown 进行编辑的，而 markdown 的插图一般需要外链，下面提供三种插图方法：</p>
<ul>
<li>在 source 文件夹中建立 images 文件夹，把需要插入的图片放到该文件夹中，然后通过相对路径 /images/image_name 进行访问。这种方法是最简单的，但由于 github page 一般空间限制为 1G，所以当图片比较多时这种方法不太合适。</li>
<li>把图片上传到第三方图床，网上很多人推荐七牛网，但似乎目前免费空间只有1G了，如果图片较多就需要花钱了。另外，这些第三方图床说不定什么时候倒闭了或者被墙了就麻烦了。</li>
<li>直接使用 github 当图床，其实就是创建一个新的 repository，可以命名为 blog_images，然后直接通过网页把需要插入的图片上传到该 repository 中。下面说一下如何获取访问地址，首先进入新建的 repository，点开需要插入的那张图片，复制浏览器中地址栏中的地址，把地址中的 blob 改成 raw 就好了，这一步很重要。虽然每个 repository 也有 1G 容量的限制，但是 reposiroty 的数量是没有限制的，你懂的。个人比较推荐这种方法。</li>
</ul>
<p>正常情况下，markdown 插入图片的语法是<code>![title](address)</code>，但这种方法不能改变插入图片的大小和位置。因此我们可以通过下面的 html 语句来设置插入图片的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;address&quot; width&#x3D;50% height&#x3D;50% align&#x3D;center&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>这条语句可以实现图片大小的设置，但是在我的博客中还不能实现居中对其，不知道是不是主题的原因。</p>
<h2 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h2><h2 id="有用链接"><a href="#有用链接" class="headerlink" title="有用链接"></a>有用链接</h2><ul>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 官方文档</a></li>
<li><a href="http://moxfive.coding.me/yelee/5.Vendor/baidu-share.html" target="_blank" rel="noopener">Yelee 主题使用说明</a></li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 参数解析</title>
    <url>/2018/01/13/python-argparse-module/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Argparse 是提升命令行运行灵活度的神器，能在每次运行的时候传递一些特定参数给程序。</p>
<a id="more"></a>


<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://mkaz.tech/code/python-argparse-cookbook/" target="_blank" rel="noopener">Argparse Cookbook</a><br>[2] <a href="https://docs.python.org/3/howto/argparse.html" target="_blank" rel="noopener">Argparse Tutorial</a><br>[3] <a href="https://docs.python.org/3/library/argparse.html" target="_blank" rel="noopener">Argparse Library</a></p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中 Logging 模块使用方法</title>
    <url>/2018/01/13/python-logging-module/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在代码调试过程中，我们使用最多的方法是 print 函数，在我们需要知道中间变量的值时，插入一句 print 函数即可。但这种方法存在一个问题，那就是在程序调试完以后我们需要一个一个把 print 函数删掉或者注释掉。logging 模块能非常好得解决这个问题，通过设置 severity level，我们可以方便得控制在控制台打印的信息，另外我们也可以同时把日志信息输出到多个目的地，比如控制台，日志文件，网络位置等。</p>
<a id="more"></a>

<h2 id="logging-基本用法"><a href="#logging-基本用法" class="headerlink" title="logging 基本用法"></a>logging 基本用法</h2><p>Logging 的基本用法非常简单，比如下面这个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(filename=<span class="string">'example.log'</span>,level=logging.DEBUG)</span><br><span class="line">logging.debug(<span class="string">'This message should go to the log file'</span>)</span><br><span class="line">logging.info(<span class="string">'So should this'</span>)</span><br><span class="line">logging.warning(<span class="string">'And this, too'</span>)</span><br></pre></td></tr></table></figure>

<p>下面简单介绍一下该程序工作流程</p>
<ul>
<li>首先导入 logging 模块。</li>
<li>然后利用函数 logging.basicConfig 设置 logger 的行为。其中，filename 指定日志文件，默认情况下，日志输出至控制台。level 指定记录日志的 severity level，logging 模块有 DEBUG, INFO, WARNING, ERROR, CRITICAL 五个从低到高的 severity level，logger 只输出与 level 参数指定级别相同更高级别的日志信息，比如，如果我们让 <code>level=logging.INFO</code>，上面程序中 logging.debug 信息在执行过程中将不会输出。当然，filenamelogging.basicConfig 可以传入很多参数，具体可以参考<a href="https://docs.python.org/2/library/logging.html#logging.basicConfig" target="_blank" rel="noopener">官方文档</a>。</li>
<li>最后在需要记录日志的地方根据需要的 severity level 添加 logging.debug 等日志信息。</li>
</ul>
<p>Logging 模块的基本用法是通过创建 Loggers 对象来实现的，Loggers 对象提供了很多方法来操作其属性，比如 setLevel 方法可以用来改变其 severity level。我们可以通过以下程序在不同模块中创建 Loggers 对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger = logging.getLogger(__name__)</span><br></pre></td></tr></table></figure>

<p>其中，<strong>name</strong> 是该模块的名字，当然我们也可以自己给该 logger 取一个名字。每次调用 logging.getLogger 便创建了一个指定名字的 logger，在同一个线程中，不管调用多少次该函数，相同名字都指向同一个 logger 对象。</p>
<p>Logging 模块通过层级结构来组织这些 loggers 对象，在同一个线程中，所有 loggers 对象都继承自 root logger，前面程序中的 logging.basicConfig 便创建了一个 root logger。loggers 对象之间的继承关系用类似于<code>a.b.c</code>的方式表示，如果子对象指定了属性，则使用它自己的属性进行输出，如果没有则使用其父对象的属性进行输出，比如前面的 logging.basicConfig 函数设置了 root logger 的属性，如果后面创建的子对象都没有设置属性，那么 root logger 的属性将在所有 logger 对象间共享。</p>
<h2 id="logging-工作流程"><a href="#logging-工作流程" class="headerlink" title="logging 工作流程"></a>logging 工作流程</h2><p>上一节介绍的是 logging 模块的基本用法，利用上面这些知识进行基本的程序调试已经没有问题了。然而，logging 模块的功能并不仅仅于此，事实上，Logging 模块包含 Loggers, Handlers, Filters 和 Formatters 等多个类，我们可以利用这些类来对日志进行更加精细化的控制。在这之前，我们需要了解 logging 模块的工作流程，如下图所示：</p>
<img src="/images/python-logging-flow.png" width=50% height=50% align=center/>

<ul>
<li>Loggers 类是整个 logger 的载体，一般使用 getLogger 方法来创建。然后我们可以为创建好的 Logger 实体设置 severity level（调用方法 Logger.setLevel()），设置 Filters（filter 能比 severity level 更精细化的控制 logger 向后面 handler 的输出，一个 logger 可以设置多个 filter，所有 filter 的过滤关系是串联的，调用方法 Logger.addFilter()），设置 Handlers（handler 的作用是指定 logger 的最终输出去向，比如可以终端输出，可以写入日志文件，可以放入某个网络服务器等，一个 loggers 可以设置多个 handler，调用方法 Logger.addHandler()）</li>
<li>Hanlder 类指定 logger 的输出去向，常用的 Handler 有 StreamHandler, FileHandler 和 SocketHandler 等。跟 Logger 类一样，我们也可以为 Handler 设置 severity level 和 filter，用法和 logger 也差不多，这样可以对最终输出进行更加精细化的控制。另外，我们可以设置最后的输出格式（调用方法 setFormatter()）</li>
<li>Formatters 和 Filters 类顾名思义就是设置最终的输出格式和滤波器</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://docs.python.org/2/howto/logging.html" target="_blank" rel="noopener">Logging HOWTO</a><br>[2] <a href="https://docs.python.org/2/howto/logging-cookbook.html" target="_blank" rel="noopener">Logging Cookbook</a><br>[3] <a href="https://docs.python.org/2/library/logging.html" target="_blank" rel="noopener">Logging facility for Python</a><br>[4] <a href="http://www.zlovezl.cn/articles/replacing-print-simple-introduction-to-logging/" target="_blank" rel="noopener">替换你的print(logging模块超简明指南)</a><br>[5] <a href="http://cblog.xyz/article/41" target="_blank" rel="noopener">logging的用法</a></p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python PEP8 编程规范总结</title>
    <url>/2018/01/09/python-pep8-program-standard/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这篇博客主要总结一些 python PEP8 的编程规范。</p>
<a id="more"></a>

<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ul>
<li>尽量单独使用小写字母‘l’，大写字母‘O’等容易混淆的字母。</li>
<li>模块命名尽量短小，使用全部小写的方式，可以使用下划线。</li>
<li>包命名尽量短小，使用全部小写的方式，不可以使用下划线。</li>
<li>类的命名使用CapWords的方式，模块内部使用的类采用_CapWords的方式。</li>
<li>异常命名使用CapWords+Error后缀的方式。</li>
<li>全局变量尽量只在模块内有效，类似C语言中的static。实现方法有两种，一是<strong>all</strong>机制;二是前缀一个下划线。</li>
<li>函数命名使用全部小写的方式，可以使用下划线。</li>
<li>常量命名使用全部大写的方式，可以使用下划线。</li>
<li>类的属性（方法和变量）命名使用全部小写的方式，可以使用下划线。</li>
<li>类的属性有3种作用域public、non-public和subclass API，可以理解成C++中的public、private、protected，non-public属性前，前缀一条下划线。</li>
<li>类的属性若与关键字名字冲突，后缀一下划线，尽量不要使用缩略等其他方式。</li>
<li>为避免与子类属性命名冲突，在类的一些属性前，前缀两条下划线。比如：类Foo中声明<strong>a,访问时，只能通过Foo._Foo</strong>a，避免歧义。如果子类也叫Foo，那就无能为力了。</li>
<li>类的方法第一个参数必须是self，而静态方法第一个参数必须是cls。</li>
</ul>
<h2 id="代码编排"><a href="#代码编排" class="headerlink" title="代码编排"></a>代码编排</h2><ul>
<li>缩进。4个空格的缩进（编辑器都可以完成此功能），不使用Tap，更不能混合使用Tap和空格。</li>
<li>每行最大长度79，换行可以使用反斜杠，最好使用圆括号。换行点要在操作符的后边敲回车。</li>
<li>类和top-level函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行</li>
</ul>
<h2 id="空格使用"><a href="#空格使用" class="headerlink" title="空格使用"></a>空格使用</h2><p>总体原则，避免不必要的空格。</p>
<ul>
<li>各种右括号前不要加空格。</li>
<li>逗号、冒号、分号前不要加空格。</li>
<li>函数的左括号前不要加空格。如Func(1)。</li>
<li>序列的左括号前不要加空格。如list[2]。</li>
<li>操作符左右各加一个空格，不要为了对齐增加空格。</li>
<li>函数默认参数使用的赋值符左右省略空格。</li>
<li>不要将多句语句写在同一行，尽管使用‘;’允许。</li>
<li>if/for/while语句中，即使执行语句只有一句，也必须另起一行。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://www.douban.com/note/134971609/" target="_blank" rel="noopener">PEP8 Python 编码规范整理</a></p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pep8</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL+phpMyAdmin 安装与使用方法</title>
    <url>/2018/10/23/mysql-tutorial/</url>
    <content><![CDATA[<p>这篇博客将介绍 MySQL 的安装，配置及其使用方法，另外，还会介绍如何使用 phpMyAdmin 这个工具来实现 MySQL 数据库的网页管理。</p>
<a id="more"></a>



<h2 id="安装与配置-MySQL"><a href="#安装与配置-MySQL" class="headerlink" title="安装与配置 MySQL"></a>安装与配置 MySQL</h2><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>Mac 下安装 MySQL 非常简单，首先<a href="http://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">下载</a> MySQL 的 dmg 安装包，然后双击安装软件。安装过程中，最新版本的 MySQL 会要求输入 root 用户的密码，并选择用户认证方式。这里认证方式建议选择第二项，如果选择第一项有可能与后面的讲到的 phpMyAdmin 不兼容，导致无法正常访问。不过选择了第一项也没关系，后面将会介绍兼容 phpMyAdmin 的方法。</p>
<p>安装完成后，把 MySQL 添加到环境变量中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>添加下列语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin</span><br></pre></td></tr></table></figure>

<p>安装完成后，可以使用过下列命令访问 mysql：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -h host_name -u user_name -p</span><br></pre></td></tr></table></figure>
<p>回车后会要求输入密码，输入安装时设置的密码即可。其中 -h 参数指定 MySQL 所在服务器的地址，如果是 localhost，该参数可省略。-u 参数指定用户名，刚安装完只有 root 一个用户。如果登录成功，将会有 mysql 命令行提示，此时就可以通过 SQL 语句来操作数据库了。需要注意的是，此时只能本机访问 mysql，远程主机访问的设置后面将会讲到。</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Linux 上的安装我只测试过[8]中介绍的 CentOS 安装，Ubuntu 没有亲自实验，有兴趣的可以参考 <a href="https://blog.csdn.net/lizuqingblog/article/details/18423751" target="_blank" rel="noopener">[3]</a> 中介绍的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载 mysql 的 repo 源</span><br><span class="line">wget http:&#x2F;&#x2F;repo.mysql.com&#x2F;mysql-community-release-el7-5.noarch.rpm</span><br><span class="line"># 安装mysql-community-release-el7-5.noarch.rpm包</span><br><span class="line">sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm</span><br><span class="line"># 安装 mysql 服务器</span><br><span class="line">sudo yum install mysql-server</span><br><span class="line"># 如果要安装客户端</span><br><span class="line">sudo yum install mysql-community-client</span><br><span class="line"># 开启 mysql 服务</span><br><span class="line">service mysql start</span><br><span class="line"># 使用 root 进入 mysql</span><br><span class="line">mysql -u root</span><br></pre></td></tr></table></figure>

<p>注意此时的 mysql 没有密码。如果登录时显示错误 ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’，可以尝试执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown root &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</span><br></pre></td></tr></table></figure>

<p>接下来重置 root 用户密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root password</span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>


<h3 id="使用宝塔面板"><a href="#使用宝塔面板" class="headerlink" title="使用宝塔面板"></a>使用宝塔面板</h3><p>宝塔面板[6]是一个可视化安装工具，可以通过浏览器一键安装 Apache 和 mysql 等常用网络工具。其安装也非常简单，执行以下两条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh</span><br><span class="line">sh install.sh</span><br></pre></td></tr></table></figure>
<p>面板默认端口为8888，可以通过浏览器进行访问。需要注意的是，宝塔面板目前只支持 python 2，如果系统安装了 python 3 可能会安装失败。</p>
<h2 id="MySQL-用户管理"><a href="#MySQL-用户管理" class="headerlink" title="MySQL 用户管理"></a>MySQL 用户管理</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE USER <span class="string">'username'</span>@<span class="string">'host'</span> IDENTIFIED BY <span class="string">'password'</span>;</span><br><span class="line">CREATE USER <span class="string">'username'</span>@<span class="string">'host'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'password'</span>;</span><br></pre></td></tr></table></figure>
<p>如果安装 MySQL 时认证方式选择的第二种，直接用第一个语句创建新用户就好了。如果安装 MySQL 时认证方式选择的第一种，然后又想用 phpMyAdmin 来管理 MySQL，就需要用第二个语句来创建新用户。其中 WITH 语句把新用户的认证方式设置成了 phpMyAdmin 能识别的 mysql_native_password，然后就可以用这个创建的新用户和密码来登录 phpMyAdmin 了。</p>
<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GRANT privileges ON database_name.table_name TO <span class="string">'user_name'</span>@<span class="string">'host'</span>;</span><br><span class="line">GRANT ALL ON *.* TO <span class="string">'user_name'</span>@<span class="string">'%'</span>;</span><br><span class="line">FLUSH PRIVILEGES</span><br></pre></td></tr></table></figure>
<p>第一个语句指定了给 username 具体的操作权限，数据库，数据表格以及主机地址。第二个语句赋予 username 所有操作权限，所有数据表格，并允许其从任意其他主机登录。最后一个语句刷新操作权限。</p>
<h2 id="利用-phpMyAdmin-来管理-MySQL"><a href="#利用-phpMyAdmin-来管理-MySQL" class="headerlink" title="利用 phpMyAdmin 来管理 MySQL"></a>利用 phpMyAdmin 来管理 MySQL</h2><p>要管理 MySQL，用命令行非常麻烦，因此可以使用开源的 phpMyAdmin 通过网页进行管理。phpMyAdmin 的安装非常简单。</p>
<h3 id="Mac-1"><a href="#Mac-1" class="headerlink" title="Mac"></a>Mac</h3><p>首先<a href="http://www.phpmyadmin.net/home_page/downloads.php" target="_blank" rel="noopener">下载</a>网页文件，并解压到 /Library/WebServer/Documents/ 目录下，完整的目录为：/Library/WebServer/Documents/phpmyadmin/。该目录为 Apache PHP 的文件目录，由于 Mac 中已经预装了 Apache 和 PHP，所以这里只需要把下载下来的文件放到 Apache 服务器文件目录就好了。</p>
<h3 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h3><p>纯净的 Linux 系统一般没有预装 Apache 和 PHP，因此需要手动安装。</p>
<ol>
<li>安装 Apache<br>正常可以使用以下命令安装[7]<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y httpd</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>如果上面命令出现 No package httpd available 问题，可以尝试使用以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum --disableexcludes&#x3D;all install -y httpd</span><br></pre></td></tr></table></figure>

<p>然后配置并启动 Apache 服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置开机自动启动</span><br><span class="line">systemctl enable httpd.service</span><br><span class="line"># 手动启动</span><br><span class="line">systemctl start httpd.service</span><br><span class="line"># 手动停止</span><br><span class="line">systemctl stop httpd.service</span><br><span class="line"># 手动重启</span><br><span class="line">systemctl restart httpd.service</span><br></pre></td></tr></table></figure>

<p>此时在浏览器输入服务器 ip 地址就能打开 Apache 的引导页了。</p>
<ol start="2">
<li><p>安装 PHP<br>在 CentOS 上如果直接执行<code>yum install php</code>可能安装的是 php5.4，而 phpmyadmin 至少需要 php5.5 以上的支持，所以这里我们介绍安装 php7 的安装方法[9]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取 php7 源</span><br><span class="line">rpm -Uvh https:&#x2F;&#x2F;mirror.webtatic.com&#x2F;yum&#x2F;el7&#x2F;webtatic-release.rpm</span><br><span class="line"># 安装 php7</span><br><span class="line">yum install php70w</span><br><span class="line"># 验证安装</span><br><span class="line">php -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 phpmyadmin<br>phpmyadmin 的安装方式与 Mac 类似，可以使用 wget 下载源文件到 /var/www/html/ 目录[10]。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取资源</span><br><span class="line">wget https:&#x2F;&#x2F;files.phpmyadmin.net&#x2F;phpMyAdmin&#x2F;4.8.3&#x2F;phpMyAdmin-4.8.3-all-languages.tar.gz</span><br><span class="line"># 解压文件</span><br><span class="line">tar -zxvf phpMyAdmin-4.8.3-all-languages.tar.gz</span><br><span class="line"># 修改文件名</span><br><span class="line">mv phpMyAdmin-4.8.3-all-languages phpmyadmin</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 php-mysqli<br>如果到此为止，登录 phpmyadmin 时可能提示缺少 php-mysqli，因此需要先安装一个 php-mysqli 包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install php-mysqli</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>进入 phpamyadmin 目录，输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp config.sample.inc.php config.inc.php</span><br><span class="line">vim config.inc.php</span><br></pre></td></tr></table></figure>

<p>修改以下两项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$cfg[&#39;blowfish_secret&#39;] &#x3D; &#39;abcdefghigklmnopqrstuvwxyz123456789&#39;;</span><br><span class="line">$cfg[&#39;Servers&#39;][$i][&#39;host&#39;] &#x3D; &#39;127.0.0.1&#39;;</span><br></pre></td></tr></table></figure>

<p>在浏览器中输入URL: <a href="http://localhost/phpmyadmin/" target="_blank" rel="noopener">http://localhost/phpmyadmin/</a>便可以进入 phpmyadmin 登录界面。输入用户名 root 和之前设置的密码，就可以登录到 MySQL 的管理界面。</p>
<h2 id="远程访问-MySQL"><a href="#远程访问-MySQL" class="headerlink" title="远程访问 MySQL"></a>远程访问 MySQL</h2><p>为了保护数据安全，默认情况下 MySQL 是不允许远程访问的。为了开启远程访问，需要修改 my.cnf 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure>

<p>修改下列三行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># skip-external-locking</span><br><span class="line"># skip-networking</span><br><span class="line">bind-address &#x3D; 0.0.0.0</span><br></pre></td></tr></table></figure>

<p>如果存在前面两条语句，直接注释掉，因为它们的作用是让 MySQL 不监听任何外部消息，而 bind-address 是指定可以访问 MySQL 的 IP 地址，0.0.0.0 表示允许所有外部 IP 访问。这个时候就可以在远程主机访问 MySQL 了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -h host_name -u user_name -p</span><br></pre></td></tr></table></figure>

<p>这里的 host_name 是安装了 MySQL 的服务器地址，user_name 这个用户必须被赋予了足够的权限（参考用户管理部分）。</p>
<p>如果无法成功连接远程 mysql 服务器，检查一下远程服务器防火墙的 3306 端口是否开启，因为 MySQL 是通过这个端口来监听外部消息的。另外，如果服务器安装在内网，远程访问还有可能被路由器防火墙拦截，这个时候就只能联系公司或学校的网络管理人员，看能不能把这个端口打开了。如果经过以上配置还是无法远程连接，可以参考[11]中的方法进行排查。</p>
<h2 id="Python-连接-MySQL"><a href="#Python-连接-MySQL" class="headerlink" title="Python 连接 MySQL"></a>Python 连接 MySQL</h2><p>MySQLdb 是 Python 连接 MySQL 最流行的一个驱动，因为它是用 C 语言写成的，效率非常高。它的缺点是由于年久失修，只支持 Python2.x，对于使用 Python3.x 的同学可以用它的 Fork 版本 mysqlclient，它可以完全兼容 MySQLdb。在 MacOS 和 Linux 上，mysqlclient 的安装也非常简单，直接用 pip 或 conda 安装即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install mysqlclient</span><br><span class="line">conda install mysqlclient</span><br></pre></td></tr></table></figure>

<p>如果安装过程中报错，可能是缺少 python3-dev 和 libmysqlclient-dev 包，可以通过以下命令安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python3-dev libmysqlclient-dev</span><br></pre></td></tr></table></figure>

<p>当然，Python 连接 MySQL 还有很多其他的驱动，感兴趣的同学可以参考 <a href="https://foofish.net/python-mysql.html" target="_blank" rel="noopener">[4]</a> 来了解它们的优缺点。</p>
<p>需要注意的是，即使安装了 mysqlclient，在写 python 代码的时候，也需要 import MySQLdb，而不是 import mysqlclient，否则会报错。</p>
<p>mysqlclient 是用原生 SQL 语言来实现数据库访问任务的，所以要求大家会使用 SQL 语言。下面用一个创建数据库的例子来展示 mysqlclient 的编程实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开数据库连接</span></span><br><span class="line">db = MySQLdb.connect(<span class="string">"host_name"</span>, <span class="string">"user_name"</span>, <span class="string">"password"</span>, <span class="string">"database_name"</span>, charset=<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 cursor() 方法获取操作游标 </span></span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果数据表已经存在，使用 execute() 方法删除表</span></span><br><span class="line">cursor.execute(<span class="string">"DROP TABLE IF EXISTS EMPLOYEE"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据表SQL语句</span></span><br><span class="line">sql = <span class="string">"""CREATE TABLE employee (</span></span><br><span class="line"><span class="string">         first_name CHAR(20) NOT NULL,</span></span><br><span class="line"><span class="string">         last_name CHAR(20),</span></span><br><span class="line"><span class="string">         age INT,  </span></span><br><span class="line"><span class="string">         sex CHAR(1),</span></span><br><span class="line"><span class="string">         income FLOAT)"""</span></span><br><span class="line"></span><br><span class="line">cursor.execute(sql)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭数据库连接</span></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>



<h2 id="有用链接"><a href="#有用链接" class="headerlink" title="有用链接"></a>有用链接</h2><p>[1] <a href="https://blog.csdn.net/u010761000/article/details/17020627" target="_blank" rel="noopener">mac下配置php+mysql</a><br>[2] <a href="https://www.jb51.net/article/31850.htm" target="_blank" rel="noopener">MySQL创建用户与授权方法</a><br>[3] <a href="https://blog.csdn.net/lizuqingblog/article/details/18423751" target="_blank" rel="noopener">Linux(Ubuntu)下MySQL的安装与配置</a><br>[4] <a href="https://foofish.net/python-mysql.html" target="_blank" rel="noopener">用 Python 连接 MySQL 的几种姿势</a><br>[5] <a href="http://www.runoob.com/python/python-mysql.html" target="_blank" rel="noopener">Python 操作 MySQL 数据库</a><br>[6] <a href="https://www.bt.cn/download/linux.html" target="_blank" rel="noopener">宝塔面板</a><br>[7] <a href="https://www.jianshu.com/p/5b8903709e66" target="_blank" rel="noopener">CentOS 7下Apache的安装</a><br>[8] <a href="https://blog.csdn.net/a774630093/article/details/79270080" target="_blank" rel="noopener">CentOS7 64位安装mysql教程，亲测完美</a><br>[9] <a href="https://www.jianshu.com/p/8d42fe65170c" target="_blank" rel="noopener">CentOs 7 安装PHP开发环境</a><br>[10] <a href="https://blog.csdn.net/daicooper/article/details/84790083" target="_blank" rel="noopener">Centos 下 phpMyAdmin 安装</a><br>[11] <a href="https://blog.csdn.net/ynnmnm/article/details/45097857" target="_blank" rel="noopener">MySQL本地可以连接，远程连接不上的问题</a></p>
]]></content>
      <categories>
        <category>data management</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>phpmyadmin</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitbook</title>
    <url>/2018/01/02/gitbook-tutorial/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><a id="more"></a>

<h2 id="安装-gitbook"><a href="#安装-gitbook" class="headerlink" title="安装 gitbook"></a>安装 gitbook</h2><p>我们可以使用 nodejs 的 npm 包管理器来安装 gitbook，nodejs 的安装方法参考我的<a href="http://zhangzhk.com/2017/09/13/how-to-create-blog-by-hexo/">这篇博客</a>。使用以下命令安装 gitbook:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gitbook -g</span><br></pre></td></tr></table></figure>

<h2 id="使用-gitbook"><a href="#使用-gitbook" class="headerlink" title="使用 gitbook"></a>使用 gitbook</h2><p>Gitbook 的使用很简单，主要是以下两条命令：</p>
<ul>
<li><code>gitbook init</code></li>
<li><code>gitbook serve</code> </li>
</ul>
<p>使用 gitbook.com 并关联 github</p>
<h2 id="发布到-github-page"><a href="#发布到-github-page" class="headerlink" title="发布到 github page"></a>发布到 github page</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:repository.git</span><br></pre></td></tr></table></figure>

<p>使用这个<a href="/files/deploy.sh">脚本</a>快速部署到 github page。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add deploy.sh</span><br><span class="line">$ git commit -m <span class="string">"Commit deploy.sh to master repository"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chmod +x deploy.sh</span><br></pre></td></tr></table></figure>



<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="http://www.chengweiyang.cn/gitbook/index.html" target="_blank" rel="noopener">GitBook 简明教程</a></p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark 的 Python 编程</title>
    <url>/2017/12/05/python-programming-for-spark/</url>
    <content><![CDATA[<p>Spark 集群的安装在我的 <a href="http://blog.csdn.net/u012604314/article/details/51606918" target="_blank" rel="noopener">CSDN 博客</a> 里面有详细介绍，这里不再赘述。另外，spark 的原理介绍有时间单独开一篇博客来讲，这篇博客主要介绍 spark 的 python 编程。</p>
<a id="more"></a>

<h2 id="Spark-环境启动"><a href="#Spark-环境启动" class="headerlink" title="Spark 环境启动"></a>Spark 环境启动</h2><p>因为最近在用 Pittsburgh Supercomputing Center(PSC) 的计算资源在学习 spark，所以这里主要介绍 PSC 的 spark 环境启动方法。</p>
<ul>
<li>利用 ssh 登录 bridges.psc.edu</li>
<li>使用<code>interact</code>命令进入计算节点</li>
<li>使用<code>module load spark</code>命令载入 spark 模块</li>
<li>使用<code>pyspark</code>命令进入 python 交互环境，这个时候就可以开始按照 python 语法进行编程了。</li>
</ul>
<p>如果想要执行 python 脚本，有以下两种方法：</p>
<ul>
<li>进入 pyspark 环境后，执行<code>execfile(&quot;python_file.py&quot;)</code></li>
<li>不进入 pyspark 编译环境，执行<code>spark-submit python_file.py</code></li>
</ul>
<p>如果是后一种方式，在编写正式 spark python 语句之前，需要在头部加入以下语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext, SparkConf</span><br><span class="line"></span><br><span class="line">conf = SparkConf()</span><br><span class="line">sc = SparkContext(conf=conf)</span><br></pre></td></tr></table></figure>



<h2 id="Spark-常用-transformation-和-action"><a href="#Spark-常用-transformation-和-action" class="headerlink" title="Spark 常用 transformation 和 action"></a>Spark 常用 transformation 和 action</h2><h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><p>常规 transformation</p>
<ul>
<li>map(func): 分别利用 func 对现有 RDD 的每个元素进行运算，生成新 RDD</li>
<li>filter(func): 选择使得通过 func 运算为真的元素，生成新 RDD</li>
<li>flatMap(func): 与 map 相比较，func 可以返回多个元素，最终 flatMap 的一个元素可以生成多个元素</li>
<li>distinct(): 返回元素不重复的 RDD</li>
</ul>
<p>Key-value transformation</p>
<ul>
<li>reduceByKey(func): 通过 key 对现有 RDD 进行 reduce，reduce 方法由 func 指定</li>
<li>sortByKey(): 返回经过 key 排序后的 RDD</li>
</ul>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>常规 action</p>
<ul>
<li>collect(): 返回 RDD 的所有元素</li>
<li>count(): 返回 RDD 所有元素的个数</li>
<li>take(n): 返回 RDD 前 n 个元素</li>
</ul>
<p>Key-value action</p>
<ul>
<li>countByKey(): 返回每个 key 元素的个数</li>
<li>lookup(key): 返回指定 key 的所有元素</li>
</ul>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>下面以一个例子来说明 spark python 的使用方法。本例子要实现的任务是对一个包含 Shakespeare 所有著作的文件，统计出现次数最多的几个词。Spark python 实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读入 txt 文件，放到 rdd 中，其中 sc 代表 spark context</span></span><br><span class="line">rdd = sc.textFile(<span class="string">"Complete_Shakespeare.txt"</span>);</span><br><span class="line"><span class="comment"># 在读入的 rdd 中，一个元素代表一行文字，下面这条语句把行拆分成单词，使得 words_rdd 的每个元素代表一个单词，其中 lambda 是 python 中嵌入式函数定义方法，分号前面是输入参数，后面是函数实现方法</span></span><br><span class="line">words_rdd = rdd.flatMap(<span class="keyword">lambda</span> x: x.split());</span><br><span class="line"><span class="comment"># 把 words_rdd 转化成 key-value 的形式，以充分利用 key-value transformation 的功能</span></span><br><span class="line">key_value_rdd = words_rdd.map(<span class="keyword">lambda</span> x: (x,<span class="number">1</span>));</span><br><span class="line"><span class="comment"># 在 key_value_rdd 中，key 为单词，value 为 1，在 word_counts_rdd 中，key 为单词，value 为该单词出现的次数</span></span><br><span class="line">word_counts_rdd = key_value_rdd.reduceByKey(<span class="keyword">lambda</span> x,y: (x+y));</span><br><span class="line"><span class="comment"># key 和 value 互换位置</span></span><br><span class="line">flipped_rdd = word_counts_rdd.map(<span class="keyword">lambda</span> x: (x[<span class="number">1</span>],x[<span class="number">0</span>]));</span><br><span class="line"><span class="comment"># 互换位置后就可以通过 key 进行排序了</span></span><br><span class="line">result_rdd = flipped_rdd.sortByKey(<span class="literal">False</span>);</span><br><span class="line"><span class="comment"># 取出出现次数最多的前 n 个单词</span></span><br><span class="line">result_rdd.take(n)</span><br></pre></td></tr></table></figure>




<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2>]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>spark</tag>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Kodi 设置教程</title>
    <url>/2018/01/02/setting-kodi/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kodi 是一个强大的流媒体播放软件，支持 macos, windows, linux, ios 以及 android 等众多平台，使得其能在各种手机、电脑、平板以及机顶盒中运行。另外，Kodi 拥有上千种插件，大大扩展了它的功能。</p>
<a id="more"></a>



<h2 id="软件安装及中文界面设置"><a href="#软件安装及中文界面设置" class="headerlink" title="软件安装及中文界面设置"></a>软件安装及中文界面设置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>对于 macos, windows, linux 以及 android 系统来说，直接到<a href="https://kodi.tv/" target="_blank" rel="noopener">Kodi 官网</a>下载安装包安装即可。</li>
<li>由于正版 ios 系统只能通过 App store 安装软件，而由于版权问题，在苹果的 App store 并找不到 Kodi，所以在 ios 系统中安装 Kodi 稍微麻烦一些。最简单的方法就是越狱，然后通过 Cydia 商店安装 Kodi。但很多人可能并不想为了一个软件而越狱，所以可以使用 <a href="https://www.macworld.co.uk/how-to/iosapps/how-install-kodi-on-iphone-or-ipad-without-jailbreaking-3634908/" target="_blank" rel="noopener">[2]</a> 中提供的方法进行安装，亲测利用 Xcode 进行安装是有效的。Xcode 是开发苹果各种系统中 App 的集成开发环境，为了使得开发的 ios app 能在手机中进行测试，Xcode 提供了把 ipa 软件包安装到 ios 设备的功能，Xcode 可以通过 mac 的 App store 进行安装。顺便吐槽一下，最新版本 Xcode 太大了，安装包就5.5G，安装到 macbook 中以后已经达到15G了。</li>
</ul>
<h3 id="中文界面设置"><a href="#中文界面设置" class="headerlink" title="中文界面设置"></a>中文界面设置</h3><p>不同系统中 Kodi 的界面有所差别，部分功能的位置可能不一样，需要根据自己的系统找一下。本教程全部基于 macos 系统。</p>
<p>Kodi 主界面左上方有三个按钮，分别是 power，setting 和 search。首先，进入 setting -&gt; interface setting -&gt; skin -&gt; fonts，把字体改成 Arial based，否则切换成中文字体后就变成乱码了。然后进入 interface setting -&gt; regional -&gt; language，选择 chinese(simplify)。</p>
<p>友情提醒：如果想要返回上一个界面，可以在空白位置单击右键，或者按 esc 键。</p>
<h2 id="插件库安装"><a href="#插件库安装" class="headerlink" title="插件库安装"></a>插件库安装</h2><p>到目前为止，Kodi 只是一个普通的播放器，还不能搜索网上的视频资源，我们需要通过安装不同插件来访问不同资源。Kodi 安装插件有两种方法，一种是通过 zip 文件安装，也就是安装包安装，另一种方法是通过插件库进行安装。熟悉 Linux 操作系统的人应该对这两种安装方式很熟悉，第一种类似于 deb 等安装包安装，第二种类似于包管理软件 apt-get 等。和 Linux 软件安装一样，利用安装包进行安装经常会遇到包依赖的问题，解决起来非常麻烦，所以推荐使用插件库进行安装，插件库安装的好处是它会自动帮我们解决包依赖的问题。安装完成后，Kodi 自带有官方插件库，但有些常用插件是找不到的，比如我们后面强烈推荐的 Exodus 插件。因此，我们需要安装一些第三方插件库，下面介绍一下安装第三方插件库的方法。</p>
<ul>
<li>返回主界面，进入 setting -&gt; file manager，双击 add source，单击 None 那个文本框，输入地址（后面会介绍几个好用的库），然后在下面的文本框给这个库取个方便自己记忆的名字，点击 OK。</li>
<li>返回主界面，左侧菜单栏有一些列表，进入 add-ons，再点击界面左上方类似于盒子的图标，点击 install from zip file，选择上一步添加的插件库名称，进去后会有一个 zip 文件，直接单击自动安装就好了。安装好后界面右上角会弹窗提醒安装完成。</li>
<li>这个时候在 install from zip file 上面有一个 install from repository，点击进入就能看到我们刚才安装的插件库了。进入插件库就能看到非常多的插件库，这个时候只要单击感兴趣的插件就能自动安装该插件了。</li>
</ul>
<p>需要注意的是，插件库也属于一种插件，因此安装插件库只能通过 zip 安装方式安装。当然，有些第三方库能在网上直接下载到 zip 安装文件，就可以不用跟上面这么麻烦，直接通过包安装方式安装就好了。</p>
<p>可能是版权问题，目前很多第三方库都已经失效了，比如以前很火的 fusion 库。因此，我在网上找了几个替代的库提供给大家，写本篇博客的时候这些库还是有效的。如果发现这些库失效了，可以自己在网上找找替代的库。</p>
<p>可以通过前面提到的方法安装：</p>
<ul>
<li>XvBMC REPsitory: <a href="http://archive.org/download/repository.xvbmc" target="_blank" rel="noopener">http://archive.org/download/repository.xvbmc</a></li>
<li>SuperRepo: <a href="http://srp.nu" target="_blank" rel="noopener">http://srp.nu</a></li>
</ul>
<p>直接下载 zip 文件到任意目录，然后通过包安装方式安装：</p>
<ul>
<li>Chinese: <a href="https://github.com/taxigps/xbmc-addons-chinese" target="_blank" rel="noopener">https://github.com/taxigps/xbmc-addons-chinese</a></li>
</ul>
<h2 id="好用插件推荐及其设置"><a href="#好用插件推荐及其设置" class="headerlink" title="好用插件推荐及其设置"></a>好用插件推荐及其设置</h2><h3 id="视频插件"><a href="#视频插件" class="headerlink" title="视频插件"></a>视频插件</h3><ul>
<li>Exodus: 这是我目前发现最好用的视频插件，这个插件可以自动在上百个视频播放源搜索想要播放的那个视频，甚至很多能搜到1080p的视频源。在 Exodus 中，英文电影，电视剧和纪录片资源都非常全，包括很多刚上映的电影（当然刚上映的很多只有枪版），中文电影也能找到很多，但部分冷门电影可能找不到播放源。Exodus 在上面提供的 XvBMC REPsitory 可以找到，我们可以通过以下方式安装 Exodus：首先通过上面插件安装库的安装方法安装 XvBMC REPsitory，然后 install from repository -&gt; XvBMC REPsitory -&gt; Add-on repository -&gt; tknorris release repository -&gt; install，最后回到 install from repository，选择安装好的 tknorris release repository，video add-ons -&gt; Exodus -&gt; install。</li>
</ul>
<h3 id="字幕插件"><a href="#字幕插件" class="headerlink" title="字幕插件"></a>字幕插件</h3><ul>
<li>opensubtitles: 这个插件的英文字幕非常全，可以在 Kodi 的官方库 Kodi add-on repository -&gt; subtitle 中找到。需要说明的是，使用这个字幕库需要到 <a href="www.opensubtitle.org">opensubtitles</a> 官网注册一下，然后在插件安装界面的 install 下面有一个 configure，把用户名和密码填进去就好了。</li>
</ul>
<p>下面三个字幕库可以找到中文字幕，不需要设置用户名密码，并且在 chinese 插件库里都能找到：</p>
<ul>
<li>163sub</li>
<li>shooter(fake)：这个是国内著名的伪射手网</li>
<li>zimuzu：这个是人人影视的字幕</li>
</ul>
<p>安装好字幕插件后，播放视频时可以在右下角找到字幕按钮，下载想要的字幕就可以了。当然有些搜出来的字幕不同步，换一个就好了。</p>
<h3 id="直播插件"><a href="#直播插件" class="headerlink" title="直播插件"></a>直播插件</h3><ul>
<li>PVR IPTV simple client: 安装方法为，主界面 -&gt; add-ons -&gt; my add-ons -&gt; PVR clients -&gt; PVR IPTV simple client。安装完以后也需要在 configure 里面设置一下，configure -&gt; general，location 选择 local path，m3u playlist path 这里首先下载 <a href="/files/playlist.m3u">m3u</a> 文件放在任意位置，然后 m3u playlist path 设置成这个 m3u 文件的存放地址就好了。这个 m3u 文件列的是直播源，其中很多直播源过段时间可能会失效，我会保持更新，当然一些国外节目也可以在 <a href="http://iptv.filmover.com/" target="_blank" rel="noopener">[3]</a> 中找，按照 m3u 文件的格式自己更新，每次更新完 m3u 文件后都要重启 kodi 才能生效。设置好以后就可以在主界面的 TV -&gt; channel 中看到添加的电视节目了。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://kodi.tv/" target="_blank" rel="noopener">Kodi 官网</a><br>[2] <a href="https://www.macworld.co.uk/how-to/iosapps/how-install-kodi-on-iphone-or-ipad-without-jailbreaking-3634908/" target="_blank" rel="noopener">在不越狱的 iOS 系统上安装 Kodi</a><br>[3] <a href="http://iptv.filmover.com/" target="_blank" rel="noopener">m3u 播放源</a></p>
]]></content>
      <categories>
        <category>entertainment</category>
      </categories>
      <tags>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>线性规划求解器总结与比较</title>
    <url>/2018/10/27/summary-linear-programming-solver/</url>
    <content><![CDATA[<p>目前的一个研究课题，需要求解一个大规模的线性规划问题，变量规模至少在 10 万的水平，需要找到找到一个高效的求解器。为此，专门花时间对比了 CBC, GLPK 等开源求解器和 CPLEX, GUROBI 等商用求解器，并对比了求解器官方 Python 接口及 CVXOPT, CVXPY, PuLP 等第三方 python 接口的求解效率。</p>
<a id="more"></a>



<h2 id="求解器及官方-Python-接口安装与使用"><a href="#求解器及官方-Python-接口安装与使用" class="headerlink" title="求解器及官方 Python 接口安装与使用"></a>求解器及官方 Python 接口安装与使用</h2><p>这篇教程主要介绍类 UNIX 系统（包括 Linux, Mac OS, AIX, Cygwin 和 MSys 等）下的安装与使用，window 下的安装由于笔者并没有亲自试验过，就不详细讲解了。如果有需要，大家可以自行在网上查找资料。</p>
<h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><p>CBC 是开源基金会 <a href="https://www.coin-or.org/" target="_blank" rel="noopener">COIN-OR</a> (Computational Infrastructure for Operations Research) 开发的线性规划求解器。该基金会开发了大量的运筹学工具，截止 2011 年，已经开发并维护了 48 个项目。</p>
<p>CBC 有很多安装方案，这里仅介绍笔者实验成功过的 Git 源码安装的方式，其他方式可以参考<a href="https://projects.coin-or.org/svn/Cbc/trunk/INSTALL" target="_blank" rel="noopener">官方文档</a>。</p>
<p>假设我们想要安装稳定的 2.9 版本，cd 到我们想要安装 CBC 的目录，然后执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --branch=stable/2.9 https://github.com/coin-or/Cbc Cbc-2.9</span><br></pre></td></tr></table></figure>

<p>下载完 CBC 源码后还要下载相应的依赖，否则会报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Cbc-2.9</span><br><span class="line">git <span class="built_in">clone</span> --branch=stable/0.8 https://github.com/coin-or-tools/BuildTools</span><br><span class="line">./BuildTools/get.dependencies.sh fetch</span><br></pre></td></tr></table></figure>

<p>有了源码和依赖，我们就可以执行典型的 Linux 源码安装步骤了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">../configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>CBC 有一个 COIN-OR 官方开发的 Python 接口 CyLP。安装方法可以参考<a href="http://mpy.github.io/CyLPdoc/" target="_blank" rel="noopener">官方文档</a>，不过按照教程，笔者尝试了各种方法都没有成功，这里就不详细讲解了。如果有人安装成功了，可以在评论区分享你的经验。</p>
<h3 id="GLPK"><a href="#GLPK" class="headerlink" title="GLPK"></a>GLPK</h3><p>GLPK (GNU Linear Programming Kit) 是 GNU 项目开发并维护的一个线性规划工具包。在 Ubuntu 和 MacOS 下安装 GLPK 非常简单，用它们相应的安装工具就好了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install glpk // Ubuntu</span><br><span class="line">sudo brew install glpk // MacOS</span><br></pre></td></tr></table></figure>

<p>GLPK 好像没有官方 Python 接口，不过可以很容易得被后面讲到的 CVXOPT, PuLP 和 CVXPY 等第三方接口调用。</p>
<h3 id="CPLEX"><a href="#CPLEX" class="headerlink" title="CPLEX"></a>CPLEX</h3><p>CPLEX 是 IBM 开发的一个商用线性规划求解器。社区版只能解决变量数量低于 1000 以及约束数量低于 1000 的问题。好在 IBM 提供了供高校学生和老师使用的完整版本，通过教育邮箱注册即可获得。首先前往购买学生版<a href="https://ibm.onthehub.com/WebStore/OfferingDetails.aspx?o=733c3d21-0ce1-e711-80fa-000d3af41938" target="_blank" rel="noopener">链接</a>，点击 add to cart，会跳转到登录和注册页面，此时可以用自己的教育邮箱注册一个账号，然后就可以免费获得 CPLEX 了。CPLEX 在 MacOS 上的安装非常简单，在自己的账户下载安装包，双击安装包，按提示一步步安装好就行。</p>
<p>CPLEX 提供了官方 python 接口，需要通过安装文件里的 setup.py 文件进行安装，具体方法为 cd 到 CPLEX 的安装目录，然后运行 setup.py 进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> cplex_home_path/python</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>

<p>直接运行 setup.py 将把 python 接口安装到默认位置，如果想要指定安装目录，可以指定 –home 参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python setup.py install --home python_package_home/cplex</span><br></pre></td></tr></table></figure>

<p>我一直使用 pyenv 来管理 python 环境（使用方法可以参考我之前的<a href="http://zhangzhk.com/2017/10/19/build-python-development-environment-in-mac/">博客</a>），所以在我的电脑上，python_package_home 一般在 <code>~/.pyenv/versions/anaconda/lib/python/site-packages/cplex</code>。使用这种方法，python 文件放在 CPLEX python 目录下的 <code>cplex/bin/python/cplex</code> 里面，在程序里面直接 import cplex 无法识别，需要把里层 cplex 目录里面的文件复制到外层 cplex 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp -ri path_to_site-packages/cplex/bin/python/cplex/* path_to_site-packages/cplex/</span><br></pre></td></tr></table></figure>

<p>这样就可以正常 import cplex 了，具体的编程方法可以参考 <a href="https://www.ibm.com/support/knowledgecenter/SSSA5P_12.7.0/ilog.odms.cplex.help/CPLEX/GettingStarted/topics/tutorials/ataglance/Python.html" target="_blank" rel="noopener">[5]</a>。</p>
<h3 id="GUROBI"><a href="#GUROBI" class="headerlink" title="GUROBI"></a>GUROBI</h3><p>GUROBI 也是一个商用求解器，实测其性能比 CPLEX 可能要稍微好一点。一点点八卦，GUROBI 是 CPLEX 的三个创始人离职后开发的一个求解器，名字是三个创始人姓氏的前两个字母组合(Zonghao GU + Edward ROthberg + Robert BIxby)。</p>
<p>安装方法也很简单，前往<a href="http://www.gurobi.com/downloads/gurobi-optimizer" target="_blank" rel="noopener">官网</a>下载相应版本，然后根据<a href="https://packages.gurobi.com/8.1/README.txt" target="_blank" rel="noopener">readme</a>的步骤安装。在 MacOS 下直接双击安装包就行。GUROBI 也提供了教育版 license <a href="http://www.gurobi.com/academia/for-universities" target="_blank" rel="noopener">[7]</a>，利用教育邮箱就能申请到一个有效的 license，然后根据官方教程安装即可使用。</p>
<p>GUROBI 的 python 接口可以直接使用 conda 来安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --add channels http://conda.anaconda.org/gurobi</span><br><span class="line">conda install gurobi</span><br></pre></td></tr></table></figure>

<p>具体编程方法可以参看 <a href="http://www.gurobi.com/documentation/8.0/quickstart_mac/py_python_interface.html" target="_blank" rel="noopener">[13]</a>。</p>
<h2 id="Python-第三方接口安装与使用"><a href="#Python-第三方接口安装与使用" class="headerlink" title="Python 第三方接口安装与使用"></a>Python 第三方接口安装与使用</h2><h3 id="CVXOPT"><a href="#CVXOPT" class="headerlink" title="CVXOPT"></a>CVXOPT</h3><p>CVXOPT 的安装非常简单，直接用 conda 安装就行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install cvxopt</span><br></pre></td></tr></table></figure>

<p>CVXOPT 实际上是一个凸优化工具包，并自带有线性规划求解器，但效率不是很高。但它可以调用外部求解器 <a href="https://cvxopt.org/userguide/coneprog.html?highlight=lp#linear-programming" target="_blank" rel="noopener">[8]</a>，包括 <a href="https://www.gnu.org/software/glpk/glpk.html" target="_blank" rel="noopener">GLPK</a>, <a href="https://www.mosek.com/" target="_blank" rel="noopener">MOSEK</a> 和 <a href="https://www.mcs.anl.gov/hs/software/DSDP/" target="_blank" rel="noopener">DSDP</a>。</p>
<p>CVXOPT 的使用方法可以参考它的官方文档 <a href="http://cvxopt.org/" target="_blank" rel="noopener">[9]</a>。</p>
<h3 id="CVXPY"><a href="#CVXPY" class="headerlink" title="CVXPY"></a>CVXPY</h3><p>CVXPY 是 Stanford 的 Steven Boyd 课题组开发的，做凸优化的同学肯定看过他的《Convex Optimization》这本书。CVXPY 也可以用 conda 进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge lapack</span><br><span class="line">conda install -c cvxgrp cvxpy</span><br></pre></td></tr></table></figure>

<p>CVXPY 是一个纯粹的 python 优化工具接口，它本身并没有实现任何求解器，都是根据问题类型调用相应的外部求解器 <a href="https://www.cvxpy.org/tutorial/advanced/index.html#choosing-a-solver" target="_blank" rel="noopener">[10]</a>，然后解析结果。对于线性规划问题，可以调用外部的 CBC, GLPK, CPLEX, GUROBI, MOSEK 等。需要注意的是，当需要调用 CBC 时，必须先安装其官方 python 接口 CyLP；当需要调用 CPLEX 时也需要先安装其官方 python 接口。</p>
<p>CVXPY 的建模过程非常直观，可以使用 numpy 的 ndarray。具体使用方法可以参考它的官方文档 <a href="https://www.cvxpy.org/tutorial/intro/index.html" target="_blank" rel="noopener">[11]</a></p>
<h3 id="PuLP"><a href="#PuLP" class="headerlink" title="PuLP"></a>PuLP</h3><p>PuLP 可以使用 pip 进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pulp</span><br></pre></td></tr></table></figure>

<p>PulP 也可以调用 CBC, GLPK, CPLEX, GUROBI 等外部线性规划求解器。具体使用方法可以参考它的官方文档 <a href="https://pythonhosted.org/PuLP/index.html" target="_blank" rel="noopener">[12]</a></p>
<h2 id="求解器及其-python-接口的性能比较"><a href="#求解器及其-python-接口的性能比较" class="headerlink" title="求解器及其 python 接口的性能比较"></a>求解器及其 python 接口的性能比较</h2><p>下面列出的结果仅仅基于我目前一个关于最小流的研究课题，更全面的分析与比较可以参考文档<a href="/files/Comparison-of-Open-Source-Linear-Programming-Solvers.pdf">[1]</a>。</p>
<ul>
<li>GLPK 对于变量规模很大的线性规划问题求解速度非常慢。</li>
<li>CPLEX 求解大规模线性规划问题非常快，但是使用官方提供的方法建模时间非常长。实际测试，在变量规模为 65536 时，建模花费 20s 左右，求解花费不到 1s。当使用 CVXPY 调用 CPLEX 时，同样规模一共花费 5s 左右，推测主要时间也是花费在建模上面。</li>
<li>比较 CVXPY 调用默认求解器，CPLEX, GUROBI，发现速度差距不大，相对来说 GUROBI 可能会稍微好一点。</li>
</ul>
<h2 id="有用链接"><a href="#有用链接" class="headerlink" title="有用链接"></a>有用链接</h2><p>[1] <a href="/files/Comparison-of-Open-Source-Linear-Programming-Solvers.pdf">Comparison of Open-Source Linear Programming Solvers</a><br>[2] <a href="https://projects.coin-or.org/svn/Cbc/trunk/INSTALL" target="_blank" rel="noopener">CBC install</a><br>[3] <a href="https://scaron.info/blog/linear-programming-in-python-with-cvxopt.html" target="_blank" rel="noopener">Linear Programming in Python with CVXOPT</a><br>[4] <a href="https://ibm.onthehub.com/WebStore/OfferingDetails.aspx?o=733c3d21-0ce1-e711-80fa-000d3af41938" target="_blank" rel="noopener">CLPEX for student</a><br>[5] <a href="https://www.ibm.com/support/knowledgecenter/SSSA5P_12.7.0/ilog.odms.cplex.help/CPLEX/GettingStarted/topics/tutorials/ataglance/Python.html" target="_blank" rel="noopener">Using the python API</a><br>[6] <a href="https://packages.gurobi.com/8.1/README.txt" target="_blank" rel="noopener">Installation tutorial</a><br>[7] <a href="http://www.gurobi.com/academia/for-universities" target="_blank" rel="noopener">Gurobi For Universities</a><br>[8] <a href="https://cvxopt.org/userguide/coneprog.html?highlight=lp#linear-programming" target="_blank" rel="noopener">Linear programming for cvxopt</a><br>[9] <a href="http://cvxopt.org/" target="_blank" rel="noopener">CVXOPT tutorial</a><br>[10] <a href="https://www.cvxpy.org/tutorial/advanced/index.html#choosing-a-solver" target="_blank" rel="noopener">Choosing a solver for CVXPY</a><br>[11] <a href="https://www.cvxpy.org/tutorial/intro/index.html" target="_blank" rel="noopener">CVXPY tutorial</a><br>[12] <a href="https://pythonhosted.org/PuLP/index.html" target="_blank" rel="noopener">PuLP tutorial</a><br>[13] <a href="http://www.gurobi.com/documentation/8.0/quickstart_mac/py_python_interface.html" target="_blank" rel="noopener">GUROBI python interface</a></p>
]]></content>
      <categories>
        <category>optimization</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>linear programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 开发过程中遇到问题总结</title>
    <url>/2017/10/25/problem-in-python-development/</url>
    <content><![CDATA[<p>在 python 开发过程中，经常遇到各种小问题，有的时候一个小问题便需要花大半天甚至数天时间才能解决。为方便今后查找，这篇博客主要记录在 python 开发过程中遇到的各种小问题以及相应的解决方法。</p>
<a id="more"></a>

<h2 id="ipython-重新加载模块"><a href="#ipython-重新加载模块" class="headerlink" title="ipython 重新加载模块"></a>ipython 重新加载模块</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>为了提高加载速度，ipython 运行过程中对所有的 module 只会 import 一次，而在稍微大一些的项目中，往往需要编写多个 module 以方便管理。这样一来，当需要在 submodule 里面修改内容时，主程序并不能及时更新，使用的还是最开始加载的内容。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>最简单的解决方法就是每次修改 submodule 内容以后重启 ipython，但这样做非常麻烦而且有可能丢失数据。下面介绍一种利用 ipython 的 autoreload 扩展 [1]彻底解决该问题的方法：</p>
<p>在 ipython 的配置文件 ~/.ipython/profile_default/ipython_config.py 中添加下面两段内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c.InteractiveShellApp.extensions = [<span class="string">'autoreload'</span>]     </span><br><span class="line">c.InteractiveShellApp.exec_lines = [<span class="string">'%autoreload 2'</span>]</span><br></pre></td></tr></table></figure>
<p>如果目前 ~/.ipython/profile_default/ 文件夹中不存在 ipython_config.py，可以在终端中输入以下命令来创建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipython profile create</span><br></pre></td></tr></table></figure>

<p>该命令会自动创建 ipython 的配置文件，所有可用的配置都被注释好了，我们要做的就是根据自己的需要打开相应的配置并添加相应的内容就好了。</p>
<h2 id="Theano-和-Lasagne-模块-import-错误"><a href="#Theano-和-Lasagne-模块-import-错误" class="headerlink" title="Theano 和 Lasagne 模块 import 错误"></a>Theano 和 Lasagne 模块 import 错误</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>在 Theano 和 Lasagne 模块 import 过程中报 ImportError 错误。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>利用 pip 安装 theano 和 lasagne 模块的正确版本，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pip install theano==0.8.2</span><br><span class="line">$ pip install lasagne==0.1</span><br></pre></td></tr></table></figure>


<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://ipython.org/ipython-doc/3/config/extensions/autoreload.html" target="_blank" rel="noopener">ipython document</a></p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 快捷方式总结</title>
    <url>/2018/02/09/vim-shortcut/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>深入剖析 mnist_tutorial_pure_tf.py</title>
    <url>/2017/09/22/understanding-mnist-tutorial-pure-tf/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>mnist_tutorial_p ure_tf.py 是对抗机器学习库 cleverhans 的经典例程，我们可以通过学习这个例程来对 cleverhans 进行更加深入的了解。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.platform <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.platform <span class="keyword">import</span> flags</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> cleverhans.utils_mnist <span class="keyword">import</span> data_mnist</span><br><span class="line"><span class="keyword">from</span> cleverhans.utils_tf <span class="keyword">import</span> model_train, model_eval</span><br><span class="line"><span class="keyword">from</span> cleverhans.attacks <span class="keyword">import</span> FastGradientMethod</span><br><span class="line"><span class="keyword">from</span> cleverhans.utils <span class="keyword">import</span> AccuracyReport</span><br><span class="line"></span><br><span class="line">FLAGS = flags.FLAGS</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MLP</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  An example of a bare bones multilayer perceptron (MLP) class.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, layers, input_shape)</span>:</span></span><br><span class="line">    self.layers = layers</span><br><span class="line">    self.input_shape = input_shape</span><br><span class="line">    <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">      layer.set_input_shape(input_shape)</span><br><span class="line">      input_shape = layer.get_output_shape()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fprop</span><span class="params">(self, x, return_all=False, set_ref=False)</span>:</span></span><br><span class="line">    states = []</span><br><span class="line">    <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">      <span class="keyword">if</span> set_ref:</span><br><span class="line">        layer.ref = x</span><br><span class="line">      x = layer.fprop(x)</span><br><span class="line">      <span class="keyword">assert</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">      states.append(x)</span><br><span class="line">    <span class="keyword">if</span> return_all:</span><br><span class="line">      <span class="keyword">return</span> states</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.fprop(x)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layer</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_output_shape</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.output_shape</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linear</span><span class="params">(Layer)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_hid)</span>:</span></span><br><span class="line">    self.num_hid = num_hid</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set_input_shape</span><span class="params">(self, input_shape)</span>:</span></span><br><span class="line">    batch_size, dim = input_shape</span><br><span class="line">    self.input_shape = [batch_size, dim]</span><br><span class="line">    self.output_shape = [batch_size, self.num_hid]</span><br><span class="line">    init = tf.random_normal([dim, self.num_hid], dtype=tf.float32)</span><br><span class="line">    init = init / tf.sqrt(<span class="number">1e-7</span> + tf.reduce_sum(tf.square(init), axis=<span class="number">0</span>,</span><br><span class="line">                                               keep_dims=<span class="literal">True</span>))</span><br><span class="line">    self.W = tf.Variable(init)</span><br><span class="line">    self.b = tf.Variable(np.zeros((self.num_hid,)).astype(<span class="string">'float32'</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fprop</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.matmul(x, self.W) + self.b</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Conv2D</span><span class="params">(Layer)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, output_channels, kernel_shape, strides, padding)</span>:</span></span><br><span class="line">    self.__dict__.update(locals())</span><br><span class="line">    <span class="keyword">del</span> self.self</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set_input_shape</span><span class="params">(self, input_shape)</span>:</span></span><br><span class="line">    batch_size, rows, cols, input_channels = input_shape</span><br><span class="line">    kernel_shape = tuple(self.kernel_shape) + (input_channels,</span><br><span class="line">                                               self.output_channels)</span><br><span class="line">    <span class="keyword">assert</span> len(kernel_shape) == <span class="number">4</span></span><br><span class="line">    <span class="keyword">assert</span> all(isinstance(e, int) <span class="keyword">for</span> e <span class="keyword">in</span> kernel_shape), kernel_shape</span><br><span class="line">    init = tf.random_normal(kernel_shape, dtype=tf.float32)</span><br><span class="line">    init = init / tf.sqrt(<span class="number">1e-7</span> + tf.reduce_sum(tf.square(init),</span><br><span class="line">                                               axis=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)))</span><br><span class="line">    self.kernels = tf.Variable(init)</span><br><span class="line">    self.b = tf.Variable(np.zeros((self.output_channels,)).astype(<span class="string">'float32'</span>))</span><br><span class="line">    orig_input_batch_size = input_shape[<span class="number">0</span>]</span><br><span class="line">    input_shape = list(input_shape)</span><br><span class="line">    input_shape[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dummy_batch = tf.zeros(input_shape)</span><br><span class="line">    dummy_output = self.fprop(dummy_batch)</span><br><span class="line">    output_shape = [int(e) <span class="keyword">for</span> e <span class="keyword">in</span> dummy_output.get_shape()]</span><br><span class="line">    output_shape[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    self.output_shape = tuple(output_shape)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fprop</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.conv2d(x, self.kernels,</span><br><span class="line">                        (<span class="number">1</span>,) + tuple(self.strides) + (<span class="number">1</span>,), self.padding)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReLU</span><span class="params">(Layer)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set_input_shape</span><span class="params">(self, shape)</span>:</span></span><br><span class="line">    self.input_shape = shape</span><br><span class="line">    self.output_shape = shape</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_output_shape</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.output_shape</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fprop</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.relu(x)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Softmax</span><span class="params">(Layer)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set_input_shape</span><span class="params">(self, shape)</span>:</span></span><br><span class="line">    self.input_shape = shape</span><br><span class="line">    self.output_shape = shape</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fprop</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.softmax(x)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flatten</span><span class="params">(Layer)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set_input_shape</span><span class="params">(self, shape)</span>:</span></span><br><span class="line">    self.input_shape = shape</span><br><span class="line">    output_width = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> factor <span class="keyword">in</span> shape[<span class="number">1</span>:]:</span><br><span class="line">      output_width *= factor</span><br><span class="line">    self.output_width = output_width</span><br><span class="line">    self.output_shape = [<span class="literal">None</span>, output_width]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fprop</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.reshape(x, [<span class="number">-1</span>, self.output_width])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_basic_cnn</span><span class="params">(nb_filters=<span class="number">64</span>, nb_classes=<span class="number">10</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                   input_shape=<span class="params">(None, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span>)</span>:</span></span><br><span class="line">  layers = [Conv2D(nb_filters, (<span class="number">8</span>, <span class="number">8</span>), (<span class="number">2</span>, <span class="number">2</span>), <span class="string">"SAME"</span>),</span><br><span class="line">            ReLU(),</span><br><span class="line">            Conv2D(nb_filters * <span class="number">2</span>, (<span class="number">6</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">2</span>), <span class="string">"VALID"</span>),</span><br><span class="line">            ReLU(),</span><br><span class="line">            Conv2D(nb_filters * <span class="number">2</span>, (<span class="number">5</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">1</span>), <span class="string">"VALID"</span>),</span><br><span class="line">            ReLU(),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(nb_classes),</span><br><span class="line">            Softmax()]</span><br><span class="line"></span><br><span class="line">  model = MLP(layers, input_shape)</span><br><span class="line">  <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mnist_tutorial</span><span class="params">(train_start=<span class="number">0</span>, train_end=<span class="number">60000</span>, test_start=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                   test_end=<span class="number">10000</span>, nb_epochs=<span class="number">6</span>, batch_size=<span class="number">128</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                   learning_rate=<span class="number">0.001</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    MNIST cleverhans tutorial</span></span><br><span class="line"><span class="string">    :param train_start: index of first training set example</span></span><br><span class="line"><span class="string">    :param train_end: index of last training set example</span></span><br><span class="line"><span class="string">    :param test_start: index of first test set example</span></span><br><span class="line"><span class="string">    :param test_end: index of last test set example</span></span><br><span class="line"><span class="string">    :param nb_epochs: number of epochs to train model</span></span><br><span class="line"><span class="string">    :param batch_size: size of training batches</span></span><br><span class="line"><span class="string">    :param learning_rate: learning rate for training</span></span><br><span class="line"><span class="string">    :return: an AccuracyReport object</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object used to keep track of (and return) key accuracies</span></span><br><span class="line">    report = AccuracyReport()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set TF random seed to improve reproducibility</span></span><br><span class="line">    tf.set_random_seed(<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create TF session</span></span><br><span class="line">    sess = tf.Session()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get MNIST test data</span></span><br><span class="line">    X_train, Y_train, X_test, Y_test = data_mnist(train_start=train_start,</span><br><span class="line">                                                  train_end=train_end,</span><br><span class="line">                                                  test_start=test_start,</span><br><span class="line">                                                  test_end=test_end)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Use label smoothing</span></span><br><span class="line">    <span class="keyword">assert</span> Y_train.shape[<span class="number">1</span>] == <span class="number">10.</span></span><br><span class="line">    label_smooth = <span class="number">.1</span></span><br><span class="line">    Y_train = Y_train.clip(label_smooth / <span class="number">9.</span>, <span class="number">1.</span> - label_smooth)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Define input TF placeholder</span></span><br><span class="line">    x = tf.placeholder(tf.float32, shape=(<span class="literal">None</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))</span><br><span class="line">    y = tf.placeholder(tf.float32, shape=(<span class="literal">None</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Define TF model graph</span></span><br><span class="line">    model = make_basic_cnn()</span><br><span class="line">    preds = model.fprop(x)</span><br><span class="line">    print(<span class="string">"Defined TensorFlow model graph."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># Evaluate the accuracy of the MNIST model on legitimate test examples</span></span><br><span class="line">        eval_params = &#123;<span class="string">'batch_size'</span>: batch_size&#125;</span><br><span class="line">        acc = model_eval(sess, x, y, preds, X_test, Y_test, args=eval_params)</span><br><span class="line">        report.clean_train_clean_eval = acc</span><br><span class="line">        <span class="keyword">assert</span> X_test.shape[<span class="number">0</span>] == test_end - test_start, X_test.shape</span><br><span class="line">        print(<span class="string">'Test accuracy on legitimate examples: %0.4f'</span> % acc)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Train an MNIST model</span></span><br><span class="line">    train_params = &#123;</span><br><span class="line">        <span class="string">'nb_epochs'</span>: nb_epochs,</span><br><span class="line">        <span class="string">'batch_size'</span>: batch_size,</span><br><span class="line">        <span class="string">'learning_rate'</span>: learning_rate</span><br><span class="line">    &#125;</span><br><span class="line">    model_train(sess, x, y, preds, X_train, Y_train, evaluate=evaluate,</span><br><span class="line">                args=train_params)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initialize the Fast Gradient Sign Method (FGSM) attack object and graph</span></span><br><span class="line">    fgsm = FastGradientMethod(model, sess=sess)</span><br><span class="line">    fgsm_params = &#123;<span class="string">'eps'</span>: <span class="number">0.3</span>&#125;</span><br><span class="line">    adv_x = fgsm.generate(x, **fgsm_params)</span><br><span class="line">    preds_adv = model.fprop(adv_x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Evaluate the accuracy of the MNIST model on adversarial examples</span></span><br><span class="line">    eval_par = &#123;<span class="string">'batch_size'</span>: batch_size&#125;</span><br><span class="line">    acc = model_eval(sess, x, y, preds_adv, X_test, Y_test, args=eval_par)</span><br><span class="line">    print(<span class="string">'Test accuracy on adversarial examples: %0.4f\n'</span> % acc)</span><br><span class="line">    report.clean_train_adv_eval = acc</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Repeating the process, using adversarial training"</span>)</span><br><span class="line">    <span class="comment"># Redefine TF model graph</span></span><br><span class="line">    model_2 = make_basic_cnn()</span><br><span class="line">    preds_2 = model_2(x)</span><br><span class="line">    fgsm2 = FastGradientMethod(model_2, sess=sess)</span><br><span class="line">    preds_2_adv = model_2(fgsm2.generate(x, **fgsm_params))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate_2</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># Accuracy of adversarially trained model on legitimate test inputs</span></span><br><span class="line">        eval_params = &#123;<span class="string">'batch_size'</span>: batch_size&#125;</span><br><span class="line">        accuracy = model_eval(sess, x, y, preds_2, X_test, Y_test,</span><br><span class="line">                              args=eval_params)</span><br><span class="line">        print(<span class="string">'Test accuracy on legitimate examples: %0.4f'</span> % accuracy)</span><br><span class="line">        report.adv_train_clean_eval = accuracy</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Accuracy of the adversarially trained model on adversarial examples</span></span><br><span class="line">        accuracy = model_eval(sess, x, y, preds_2_adv, X_test,</span><br><span class="line">                              Y_test, args=eval_params)</span><br><span class="line">        print(<span class="string">'Test accuracy on adversarial examples: %0.4f'</span> % accuracy)</span><br><span class="line">        report.adv_train_adv_eval = accuracy</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Perform and evaluate adversarial training</span></span><br><span class="line">    model_train(sess, x, y, preds_2, X_train, Y_train,</span><br><span class="line">                predictions_adv=preds_2_adv, evaluate=evaluate_2,</span><br><span class="line">                args=train_params)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> report</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv=None)</span>:</span></span><br><span class="line">    mnist_tutorial(nb_epochs=FLAGS.nb_epochs, batch_size=FLAGS.batch_size,</span><br><span class="line">                   learning_rate=FLAGS.learning_rate)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    flags.DEFINE_integer(<span class="string">'nb_epochs'</span>, <span class="number">6</span>, <span class="string">'Number of epochs to train model'</span>)</span><br><span class="line">    flags.DEFINE_integer(<span class="string">'batch_size'</span>, <span class="number">128</span>, <span class="string">'Size of training batches'</span>)</span><br><span class="line">    flags.DEFINE_float(<span class="string">'learning_rate'</span>, <span class="number">0.001</span>, <span class="string">'Learning rate for training'</span>)</span><br><span class="line"></span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>security</tag>
        <tag>cleverhans</tag>
        <tag>adversarial</tag>
      </tags>
  </entry>
  <entry>
    <title>深入剖析 fully_connected_feed.py</title>
    <url>/2017/09/21/understanding-fully-connected-feed/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>fully_connected_feed.py 是 tensorflow 中训练 MINIST 数据集的简单示例，通过对该代码的学习，可以帮助我们更好得理解 python 的语法以及 tensorflow 的工作流程。</p>
<a id="more"></a>

<h2 id="代码详细注释"><a href="#代码详细注释" class="headerlink" title="代码详细注释"></a>代码详细注释</h2><p>由于Python是由社区推动的开源并且免费的开发语言，不受商业公司控制，因此，Python的改进往往比较激进，不兼容的情况时有发生。Python为了确保你能顺利过渡到新版本，特别提供了<strong>future</strong>模块，让你在旧的版本中试验新版本的一些特性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pylint: disable=missing-docstring</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> six.moves <span class="keyword">import</span> xrange  <span class="comment"># pylint: disable=redefined-builtin</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> mnist</span><br><span class="line"></span><br><span class="line"><span class="comment"># Basic model parameters as external flags.</span></span><br><span class="line">FLAGS = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">placeholder_inputs</span><span class="params">(batch_size)</span>:</span></span><br><span class="line">  images_placeholder = tf.placeholder(tf.float32, shape=(batch_size,</span><br><span class="line">                                                         mnist.IMAGE_PIXELS))</span><br><span class="line">  labels_placeholder = tf.placeholder(tf.int32, shape=(batch_size))</span><br><span class="line">  <span class="keyword">return</span> images_placeholder, labels_placeholder</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_feed_dict</span><span class="params">(data_set, images_pl, labels_pl)</span>:</span></span><br><span class="line">  images_feed, labels_feed = data_set.next_batch(FLAGS.batch_size,</span><br><span class="line">                                                 FLAGS.fake_data)</span><br><span class="line">  feed_dict = &#123;</span><br><span class="line">      images_pl: images_feed,</span><br><span class="line">      labels_pl: labels_feed,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> feed_dict</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_eval</span><span class="params">(sess,</span></span></span><br><span class="line"><span class="function"><span class="params">            eval_correct,</span></span></span><br><span class="line"><span class="function"><span class="params">            images_placeholder,</span></span></span><br><span class="line"><span class="function"><span class="params">            labels_placeholder,</span></span></span><br><span class="line"><span class="function"><span class="params">            data_set)</span>:</span></span><br><span class="line">  true_count = <span class="number">0</span>  <span class="comment"># Counts the number of correct predictions.</span></span><br><span class="line">  steps_per_epoch = data_set.num_examples // FLAGS.batch_size</span><br><span class="line">  num_examples = steps_per_epoch * FLAGS.batch_size</span><br><span class="line">  <span class="keyword">for</span> step <span class="keyword">in</span> xrange(steps_per_epoch):</span><br><span class="line">    feed_dict = fill_feed_dict(data_set,</span><br><span class="line">                               images_placeholder,</span><br><span class="line">                               labels_placeholder)</span><br><span class="line">    true_count += sess.run(eval_correct, feed_dict=feed_dict)</span><br><span class="line">  precision = float(true_count) / num_examples</span><br><span class="line">  print(<span class="string">'  Num examples: %d  Num correct: %d  Precision @ 1: %0.04f'</span> %</span><br><span class="line">        (num_examples, true_count, precision))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_training</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">with</span> tf.Graph().as_default():</span><br><span class="line">    <span class="comment"># Generate placeholders for the images and labels.</span></span><br><span class="line">    images_placeholder, labels_placeholder = placeholder_inputs(</span><br><span class="line">        FLAGS.batch_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build a Graph that computes predictions from the inference model.</span></span><br><span class="line">    logits = mnist.inference(images_placeholder, FLAGS.hidden1, FLAGS.hidden2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add to the Graph the Ops for loss calculation.</span></span><br><span class="line">    loss = mnist.loss(logits, labels_placeholder)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add to the Graph the Ops that calculate and apply gradients.</span></span><br><span class="line">    train_op = mnist.training(loss, FLAGS.learning_rate)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add the Op to compare the logits to the labels during evaluation.</span></span><br><span class="line">    eval_correct = mnist.evaluation(logits, labels_placeholder)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build the summary Tensor based on the TF collection of Summaries.</span></span><br><span class="line">    summary = tf.summary.merge_all()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add the variable initializer Op.</span></span><br><span class="line">    init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a saver for writing training checkpoints.</span></span><br><span class="line">    saver = tf.train.Saver()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a session for running Ops on the Graph.</span></span><br><span class="line">    sess = tf.Session()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Instantiate a SummaryWriter to output summaries and the Graph.</span></span><br><span class="line">    summary_writer = tf.summary.FileWriter(FLAGS.log_dir, sess.graph)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># And then after everything is built:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run the Op to initialize the variables.</span></span><br><span class="line">    sess.run(init)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Start the training loop.</span></span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> xrange(FLAGS.max_steps):</span><br><span class="line">      start_time = time.time()</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Fill a feed dictionary with the actual set of images and labels</span></span><br><span class="line">      <span class="comment"># for this particular training step.</span></span><br><span class="line">      feed_dict = fill_feed_dict(data_sets.train, images_placeholder, labels_placeholder)</span><br><span class="line">      </span><br><span class="line">      _, loss_value = sess.run([train_op, loss], feed_dict=feed_dict)</span><br><span class="line"></span><br><span class="line">      duration = time.time() - start_time</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># Print status to stdout.</span></span><br><span class="line">        print(<span class="string">'Step %d: loss = %.2f (%.3f sec)'</span> % (step, loss_value, duration))</span><br><span class="line">        <span class="comment"># Update the events file.</span></span><br><span class="line">        summary_str = sess.run(summary, feed_dict=feed_dict)</span><br><span class="line">        summary_writer.add_summary(summary_str, step)</span><br><span class="line">        summary_writer.flush()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (step + <span class="number">1</span>) % <span class="number">1000</span> == <span class="number">0</span> <span class="keyword">or</span> (step + <span class="number">1</span>) == FLAGS.max_steps:</span><br><span class="line">        checkpoint_file = os.path.join(FLAGS.log_dir, <span class="string">'model.ckpt'</span>)</span><br><span class="line">        saver.save(sess, checkpoint_file, global_step=step)</span><br><span class="line">        <span class="comment"># Evaluate against the training set.</span></span><br><span class="line">        print(<span class="string">'Training Data Eval:'</span>)</span><br><span class="line">        do_eval(sess, eval_correct, images_placeholder, labels_placeholder, data_sets.train)</span><br><span class="line">        <span class="comment"># Evaluate against the validation set.</span></span><br><span class="line">        print(<span class="string">'Validation Data Eval:'</span>)</span><br><span class="line">        do_eval(sess, eval_correct, images_placeholder, labels_placeholder, data_sets.validation)</span><br><span class="line">        <span class="comment"># Evaluate against the test set.</span></span><br><span class="line">        print(<span class="string">'Test Data Eval:'</span>)</span><br><span class="line">        do_eval(sess, eval_correct, images_placeholder, labels_placeholder, data_sets.test)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(_)</span>:</span></span><br><span class="line">  <span class="comment"># 把之前的 log 文件删除</span></span><br><span class="line">  <span class="keyword">if</span> tf.gfile.Exists(FLAGS.log_dir):</span><br><span class="line">    tf.gfile.DeleteRecursively(FLAGS.log_dir)</span><br><span class="line">  <span class="comment"># 重新创建 log 文件</span></span><br><span class="line">  tf.gfile.MakeDirs(FLAGS.log_dir)</span><br><span class="line">  <span class="comment"># 正式开始训练</span></span><br><span class="line">  run_training()</span><br></pre></td></tr></table></figure>

<p>Python 中的 argparse 模块主要负责命令行解析。其主要作用是在 python 调用 .py 脚本文件是可以传入参数。比如对于以下程序，我们可以在命令行输入 <code>python fully_connected_feed.py --learning_rate 0.1 --max_steps 200</code>。其中 ArgumentParser() 函数的作用是定义一个 parser 实例。parser.add_argument() 函数的作用是添加输入命令参数，它的第一个参数为命令参数名称，第二个参数为命令参数类型，第三个参数为命令参数默认值，如果没有输入，那么取默认值，第四个参数为调用 help 时显示的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># if 的作用是保证此文件被 import 时，不会执行 main 里面的内容</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: </span><br><span class="line">  parser = argparse.ArgumentParser()</span><br><span class="line">  parser.add_argument(</span><br><span class="line">      <span class="string">'--learning_rate'</span>,</span><br><span class="line">      type=float,</span><br><span class="line">      default=<span class="number">0.01</span>,</span><br><span class="line">      help=<span class="string">'Initial learning rate.'</span></span><br><span class="line">  )</span><br><span class="line">  parser.add_argument(</span><br><span class="line">      <span class="string">'--max_steps'</span>,</span><br><span class="line">      type=int,</span><br><span class="line">      default=<span class="number">2000</span>,</span><br><span class="line">      help=<span class="string">'Number of steps to run trainer.'</span></span><br><span class="line">  )</span><br><span class="line">  parser.add_argument(</span><br><span class="line">      <span class="string">'--hidden1'</span>,</span><br><span class="line">      type=int,</span><br><span class="line">      default=<span class="number">128</span>,</span><br><span class="line">      help=<span class="string">'Number of units in hidden layer 1.'</span></span><br><span class="line">  )</span><br><span class="line">  parser.add_argument(</span><br><span class="line">      <span class="string">'--hidden2'</span>,</span><br><span class="line">      type=int,</span><br><span class="line">      default=<span class="number">32</span>,</span><br><span class="line">      help=<span class="string">'Number of units in hidden layer 2.'</span></span><br><span class="line">  )</span><br><span class="line">  parser.add_argument(</span><br><span class="line">      <span class="string">'--batch_size'</span>,</span><br><span class="line">      type=int,</span><br><span class="line">      default=<span class="number">100</span>,</span><br><span class="line">      help=<span class="string">'Batch size.  Must divide evenly into the dataset sizes.'</span></span><br><span class="line">  )</span><br><span class="line">  parser.add_argument(</span><br><span class="line">      <span class="string">'--input_data_dir'</span>,</span><br><span class="line">      type=str,</span><br><span class="line">      default=os.path.join(os.getenv(<span class="string">'TEST_TMPDIR'</span>, <span class="string">'/tmp'</span>),</span><br><span class="line">                           <span class="string">'tensorflow/mnist/input_data'</span>),</span><br><span class="line">      help=<span class="string">'Directory to put the input data.'</span></span><br><span class="line">  )</span><br><span class="line">  parser.add_argument(</span><br><span class="line">      <span class="string">'--log_dir'</span>,</span><br><span class="line">      type=str,</span><br><span class="line">      default=os.path.join(os.getenv(<span class="string">'TEST_TMPDIR'</span>, <span class="string">'/tmp'</span>),</span><br><span class="line">                           <span class="string">'tensorflow/mnist/logs/fully_connected_feed'</span>),</span><br><span class="line">      help=<span class="string">'Directory to put the log data.'</span></span><br><span class="line">  )</span><br><span class="line">  parser.add_argument(</span><br><span class="line">      <span class="string">'--fake_data'</span>,</span><br><span class="line">      default=<span class="literal">False</span>,</span><br><span class="line">      help=<span class="string">'If true, uses fake data for unit testing.'</span>,</span><br><span class="line">      action=<span class="string">'store_true'</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># parse_known_args() 函数的作用是把传入的参数读出来，并放到 FLAGS 里面，unparsed 里面存的是默认值。</span></span><br><span class="line">  FLAGS, unparsed = parser.parse_known_args() </span><br><span class="line">  <span class="comment"># 正式激活 main() 函数。</span></span><br><span class="line">  tf.app.run(main=main, argv=[sys.argv[<span class="number">0</span>]] + unparsed)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 Scrapy 编写爬虫程序</title>
    <url>/2020/09/11/scrapy-tutorial/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Scrapy 是目前使用最广泛的爬虫框架之一，只需要编写非常少的代码就能实现需要的爬虫功能。</p>
<a id="more"></a>



<h2 id="Scrapy-基本使用方法"><a href="#Scrapy-基本使用方法" class="headerlink" title="Scrapy 基本使用方法"></a>Scrapy 基本使用方法</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Scrapy 安装非常方便，直接使用 pip 安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install scrapy</span><br></pre></td></tr></table></figure>

<h3 id="Scrapy-编写基础爬虫程序"><a href="#Scrapy-编写基础爬虫程序" class="headerlink" title="Scrapy 编写基础爬虫程序"></a>Scrapy 编写基础爬虫程序</h3><p>首先使用以下命令自动创建一个爬虫模板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy startproject project_name</span><br></pre></td></tr></table></figure>

<p>接下来在 ‘spider’ 文件夹下建立一个爬虫文件，以下是一段模板程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DemoSpider(scrapy.Spider):</span><br><span class="line">    name &#x3D; &quot;demo&quot;</span><br><span class="line"></span><br><span class="line">    def start_requests(self):</span><br><span class="line">        urls &#x3D; [</span><br><span class="line">            &#39;http:&#x2F;&#x2F;quotes.toscrape.com&#x2F;page&#x2F;1&#x2F;&#39;,</span><br><span class="line">            &#39;http:&#x2F;&#x2F;quotes.toscrape.com&#x2F;page&#x2F;2&#x2F;&#39;,</span><br><span class="line">        ]</span><br><span class="line">        for url in urls:</span><br><span class="line">            yield scrapy.Request(url&#x3D;url, callback&#x3D;self.parse)</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        page &#x3D; response.url.split(&quot;&#x2F;&quot;)[-2]</span><br><span class="line">        filename &#x3D; &#39;quotes-%s.html&#39; % page</span><br><span class="line">        with open(filename, &#39;wb&#39;) as f:</span><br><span class="line">            f.write(response.body)</span><br><span class="line">        self.log(&#39;Saved file %s&#39; % filename)</span><br></pre></td></tr></table></figure>

<p>该程序包含三大基本组件，name 指定爬虫的名字，必须唯一。start_requests 函数向目标网址发送请求，其中 Request() 类必须指定 url 和 callback 函数，callback 函数的作用为解析 HTML 文件。parse 函数实现 HTML 解析功能，实例中实现的功能为把爬取的 HTML 文件直接存储在本地。接下来的内容将会介绍其他内容提取方法。</p>
<h3 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h3><p>很多网站比如 google 会部署反爬虫程序来减小服务器压力，如果我们直接使用本地 ip 运行大量爬虫，很有可能会被封掉。在这种情况下我们可以使用代理，这里介绍一个代理网站 <a href="https://www.scraperapi.com/" target="_blank" rel="noopener">https://www.scraperapi.com/</a>，免费版本每个月有 5000 次爬取机会。在程序中定义以下函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_url(url):</span><br><span class="line">    payload &#x3D; &#123;&#39;api_key&#39;: API_KEY, &#39;url&#39;: url, &#39;country_code&#39;: &#39;us&#39;&#125;</span><br><span class="line">    proxy_url &#x3D; &#39;http:&#x2F;&#x2F;api.scraperapi.com&#x2F;?&#39; + urlencode(payload)</span><br><span class="line">    return proxy_url</span><br></pre></td></tr></table></figure>

<p> 其中 API_KEY 在注册账户中可以找到。</p>
<h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p> Scrapy 一般使用命令行来运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy crawl demo -o save_file.jl</span><br></pre></td></tr></table></figure>

<p>其中 save_file.jl 可以使用 jsonline 格式保存爬取的数据。</p>
<p>如果想要使用 pycharm 来调试爬虫程序，可以在 setting.py 同级目录新建一个文件，并编写以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from scrapy import cmdline</span><br><span class="line"></span><br><span class="line">name &#x3D; &#39;demo&#39;</span><br><span class="line">cmd &#x3D; &#39;scrapy crawl &#123;0&#125; -o temp.jl&#39;.format(name)</span><br><span class="line">cmdline.execute(cmd.split())</span><br></pre></td></tr></table></figure>

<p>以上代码有一个问题是执行完爬虫程序就直接退出了，无法串行执行两个以上爬虫程序或者对爬取数据进行后续处理，为了解决这个问题，可以使用以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">name &#x3D; &#39;demo&#39;</span><br><span class="line">os.system(&#39;scrapy crawl &#123;0&#125; -o temp.jl&#39;.format(name))</span><br></pre></td></tr></table></figure>

<p>这行代码有一个问题是没有办法停在爬虫程序的断点处，因此没法调试爬虫。所以我现在的策略是使用 cmdline 来调试单个爬虫程序，在单个爬虫程序调试完成后，再使用 os.system 来实现爬虫数据后处理。</p>
<h2 id="Xpath-使用方法"><a href="#Xpath-使用方法" class="headerlink" title="Xpath 使用方法"></a>Xpath 使用方法</h2><p>Scrapy 使用 selector 提取 HTML 文件内容，其中 selector 有很多选择，比如 css 和 xpath，这里我们只介绍 xpath。</p>
<h3 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h3><ul>
<li>//: 提取子目录所有满足条件内容</li>
<li>/: 提取直接子目录所有满足条件内容</li>
<li>[]: 设置提取条件</li>
<li>@: 指定属性</li>
<li>text(): 提取文字</li>
</ul>
<p>一下为一个实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.xpath(&#39;&#x2F;&#x2F;div&#x2F;&#x2F;a[@class&#x3D;&quot;gsc_a_at&quot;]&#x2F;&#x2F;text()&#39;).extract()</span><br></pre></td></tr></table></figure>

<p>这段程序提取了所有 div 标签下的所有 a 标签，其中 a 标签需要带有属性 class=”gsc_a_at”，并提取满足条件标签的所有文字。extract() 把 selector 转化成 string，如果有多个满足条件的内容，将形成一个列表。</p>
<h2 id="爬取动态网页"><a href="#爬取动态网页" class="headerlink" title="爬取动态网页"></a>爬取动态网页</h2><p>实际生活中有很多网页需要通过 js 来渲染，直接使用 scrapy 无法直接爬取，因此需要借助于 splash 来实现。具体使用方法可以参考这个<a href="https://splash-cn-doc.readthedocs.io/zh_CN/latest/scrapy-splash-toturial.html" target="_blank" rel="noopener">教程</a>。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://docs.scrapy.org/en/latest/" target="_blank" rel="noopener">Scrapy documentation</a><br>[2] <a href="https://splash-cn-doc.readthedocs.io/zh_CN/latest/scrapy-splash-toturial.html" target="_blank" rel="noopener">scrapy-splash 教程</a><br>[3] <a href="https://zhuanlan.zhihu.com/p/29436838" target="_blank" rel="noopener">学爬虫利器XPath,看这一篇就够了</a><br>[4] <a href="http://plasmasturm.org/log/xpath101/" target="_blank" rel="noopener">Concise XPath</a><br>[5] <a href="https://www.scraperapi.com/" target="_blank" rel="noopener">scraperapi</a></p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>crawler</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
</search>
